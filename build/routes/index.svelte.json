{
    "server": {
        "component": "'use strict';\n\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nPromise.resolve();\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\n\n/* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\nconst css = {\n\tcode: \"@import url(\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\");h1.svelte-1oogwnu{font-size:64px}\",\n\tmap: \"{\\\"version\\\":3,\\\"file\\\":\\\"chat.svelte\\\",\\\"sources\\\":[\\\"chat.svelte\\\"],\\\"sourcesContent\\\":[\\\"<script>\\\\r\\\\n    let username = \\\\\\\"Guest\\\\\\\";\\\\r\\\\n    let newMessage = \\\\\\\"\\\\\\\";\\\\r\\\\n    let chatHistory = [];\\\\r\\\\n</script>\\\\r\\\\n\\\\r\\\\n<style>@import url(\\\\\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\\\\\");\\\\nh1 {\\\\n  font-size: 64px;\\\\n}</style>\\\\r\\\\n\\\\r\\\\n<h1>CHAT</h1>\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\"AAMO,QAAQ,IAAI,sEAAsE,CAAC,CAAC,AAC3F,EAAE,eAAC,CAAC,AACF,SAAS,CAAE,IAAI,AACjB,CAAC\\\"}\"\n};\n\nconst Chat = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\t$$result.css.add(css);\n\treturn `<h1 class=\"${\"svelte-1oogwnu\"}\">CHAT</h1>`;\n});\n\n/* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\nconst Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `${validate_component(Chat, \"Chat\").$$render($$result, {}, {}, {})}`;\n});\n\nmodule.exports = Routes;\n",
        "css": "@import url(\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\");h1.svelte-1oogwnu{font-size:64px}"
    },
    "client": {
        "js": {
            "exports": [
                "default"
            ],
            "facadeModuleId": "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte",
            "isDynamicEntry": false,
            "isEntry": true,
            "isImplicitEntry": false,
            "modules": {
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\svelte\\internal\\index.mjs": {
                    "code": "    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    let outros;\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function transition_out(block, local, detach, callback) {\n        if (block && block.o) {\n            if (outroing.has(block))\n                return;\n            outroing.add(block);\n            outros.c.push(() => {\n                outroing.delete(block);\n                if (callback) {\n                    if (detach)\n                        block.d(1);\n                    callback();\n                }\n            });\n            block.o(local);\n        }\n    }\n    function create_component(block) {\n        block && block.c();\n    }\n    function claim_component(block, parent_nodes) {\n        block && block.l(parent_nodes);\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }",
                    "originalLength": 67632,
                    "removedExports": [
                        "HtmlTag",
                        "HtmlTagHydration",
                        "SvelteComponentTyped",
                        "SvelteElement",
                        "action_destroyer",
                        "add_attribute",
                        "add_classes",
                        "add_flush_callback",
                        "add_resize_listener",
                        "add_transform",
                        "afterUpdate",
                        "append",
                        "append_dev",
                        "append_empty_stylesheet",
                        "append_styles",
                        "assign",
                        "attribute_to_object",
                        "beforeUpdate",
                        "bind",
                        "bubble",
                        "check_outros",
                        "claim_html_tag",
                        "claim_space",
                        "claim_svg_element",
                        "clear_loops",
                        "component_subscribe",
                        "compute_rest_props",
                        "compute_slots",
                        "createEventDispatcher",
                        "create_animation",
                        "create_bidirectional_transition",
                        "create_in_transition",
                        "create_out_transition",
                        "create_slot",
                        "create_ssr_component",
                        "dataset_dev",
                        "debug",
                        "destroy_block",
                        "destroy_each",
                        "detach_after_dev",
                        "detach_before_dev",
                        "detach_between_dev",
                        "each",
                        "element_is",
                        "empty",
                        "escape",
                        "escape_attribute_value",
                        "escape_object",
                        "escaped",
                        "exclude_internal_props",
                        "fix_and_destroy_block",
                        "fix_and_outro_and_destroy_block",
                        "fix_position",
                        "getAllContexts",
                        "getContext",
                        "get_all_dirty_from_scope",
                        "get_binding_group_value",
                        "get_current_component",
                        "get_custom_elements_slots",
                        "get_root_for_style",
                        "get_slot_changes",
                        "get_spread_object",
                        "get_spread_update",
                        "get_store_value",
                        "globals",
                        "group_outros",
                        "handle_promise",
                        "hasContext",
                        "has_prop",
                        "identity",
                        "insert",
                        "insert_dev",
                        "intros",
                        "invalid_attribute_name_character",
                        "is_client",
                        "is_crossorigin",
                        "is_promise",
                        "listen",
                        "listen_dev",
                        "loop",
                        "loop_guard",
                        "missing_component",
                        "not_equal",
                        "now",
                        "null_to_empty",
                        "object_without_properties",
                        "onDestroy",
                        "onMount",
                        "once",
                        "outro_and_destroy_block",
                        "prevent_default",
                        "prop_dev",
                        "query_selector_all",
                        "raf",
                        "select_multiple_value",
                        "select_option",
                        "select_options",
                        "select_value",
                        "self",
                        "setContext",
                        "set_attributes",
                        "set_custom_element_data",
                        "set_data",
                        "set_data_dev",
                        "set_input_type",
                        "set_input_value",
                        "set_now",
                        "set_raf",
                        "set_store_value",
                        "set_style",
                        "set_svg_attributes",
                        "space",
                        "spread",
                        "src_url_equal",
                        "stop_propagation",
                        "subscribe",
                        "svg_element",
                        "tick",
                        "time_ranges_to_array",
                        "to_number",
                        "toggle_class",
                        "trusted",
                        "update_await_block_branch",
                        "update_keyed_each",
                        "update_slot",
                        "update_slot_base",
                        "validate_component",
                        "validate_each_argument",
                        "validate_each_keys",
                        "validate_store",
                        "xlink_attr"
                    ],
                    "renderedExports": [
                        "SvelteComponent",
                        "SvelteComponentDev",
                        "add_location",
                        "add_render_callback",
                        "append_hydration",
                        "append_hydration_dev",
                        "attr",
                        "attr_dev",
                        "binding_callbacks",
                        "blank_object",
                        "children",
                        "claim_component",
                        "claim_element",
                        "claim_text",
                        "create_component",
                        "current_component",
                        "custom_event",
                        "destroy_component",
                        "detach",
                        "detach_dev",
                        "dirty_components",
                        "dispatch_dev",
                        "element",
                        "end_hydrating",
                        "flush",
                        "init",
                        "insert_hydration",
                        "insert_hydration_dev",
                        "is_empty",
                        "is_function",
                        "mount_component",
                        "noop",
                        "run",
                        "run_all",
                        "safe_not_equal",
                        "schedule_update",
                        "set_current_component",
                        "start_hydrating",
                        "text",
                        "transition_in",
                        "transition_out",
                        "validate_slots"
                    ],
                    "renderedLength": 18791
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.svelte": {
                    "code": "    /* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\n    const file = \"src\\\\components\\\\chat.svelte\";\n\n    function create_fragment$1(ctx) {\n    \tlet h1;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt = text(\"CHAT\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt = claim_text(h1_nodes, \"CHAT\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-1oogwnu\");\n    \t\t\tadd_location(h1, file, 11, 0, 234);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h1, anchor);\n    \t\t\tappend_hydration_dev(h1, t);\n    \t\t},\n    \t\tp: noop,\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h1);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment$1.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance$1($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Chat', slots, []);\n    \tlet username = \"Guest\";\n    \tlet newMessage = \"\";\n    \tlet chatHistory = [];\n    \tconst writable_props = [];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chat> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$capture_state = () => ({ username, newMessage, chatHistory });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('username' in $$props) username = $$props.username;\n    \t\tif ('newMessage' in $$props) newMessage = $$props.newMessage;\n    \t\tif ('chatHistory' in $$props) chatHistory = $$props.chatHistory;\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [];\n    }\n\n    class Chat extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance$1, create_fragment$1, safe_not_equal, {});\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Chat\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment$1.name\n    \t\t});\n    \t}\n    }",
                    "originalLength": 281,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 2081
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte": {
                    "code": "    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    function create_fragment(ctx) {\n    \tlet chat;\n    \tlet current;\n    \tchat = new Chat({ $$inline: true });\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tcreate_component(chat.$$.fragment);\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tclaim_component(chat.$$.fragment, nodes);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tmount_component(chat, target, anchor);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\tp: noop,\n    \t\ti: function intro(local) {\n    \t\t\tif (current) return;\n    \t\t\ttransition_in(chat.$$.fragment, local);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\to: function outro(local) {\n    \t\t\ttransition_out(chat.$$.fragment, local);\n    \t\t\tcurrent = false;\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tdestroy_component(chat, detaching);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tconst writable_props = [];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$capture_state = () => ({ Chat });\n    \treturn [];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, {});\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n    \t}\n    }",
                    "originalLength": 105,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 1586
                }
            },
            "name": "index",
            "type": "chunk",
            "code": "var Index = (function () {\n    'use strict';\n\n    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    let outros;\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function transition_out(block, local, detach, callback) {\n        if (block && block.o) {\n            if (outroing.has(block))\n                return;\n            outroing.add(block);\n            outros.c.push(() => {\n                outroing.delete(block);\n                if (callback) {\n                    if (detach)\n                        block.d(1);\n                    callback();\n                }\n            });\n            block.o(local);\n        }\n    }\n    function create_component(block) {\n        block && block.c();\n    }\n    function claim_component(block, parent_nodes) {\n        block && block.l(parent_nodes);\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }\n\n    /* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\n    const file = \"src\\\\components\\\\chat.svelte\";\n\n    function create_fragment$1(ctx) {\n    \tlet h1;\n    \tlet t;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt = text(\"CHAT\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt = claim_text(h1_nodes, \"CHAT\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-1oogwnu\");\n    \t\t\tadd_location(h1, file, 11, 0, 234);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h1, anchor);\n    \t\t\tappend_hydration_dev(h1, t);\n    \t\t},\n    \t\tp: noop,\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h1);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment$1.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance$1($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Chat', slots, []);\n    \tlet username = \"Guest\";\n    \tlet newMessage = \"\";\n    \tlet chatHistory = [];\n    \tconst writable_props = [];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chat> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$capture_state = () => ({ username, newMessage, chatHistory });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('username' in $$props) username = $$props.username;\n    \t\tif ('newMessage' in $$props) newMessage = $$props.newMessage;\n    \t\tif ('chatHistory' in $$props) chatHistory = $$props.chatHistory;\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [];\n    }\n\n    class Chat extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance$1, create_fragment$1, safe_not_equal, {});\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Chat\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment$1.name\n    \t\t});\n    \t}\n    }\n\n    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\n    function create_fragment(ctx) {\n    \tlet chat;\n    \tlet current;\n    \tchat = new Chat({ $$inline: true });\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tcreate_component(chat.$$.fragment);\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tclaim_component(chat.$$.fragment, nodes);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tmount_component(chat, target, anchor);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\tp: noop,\n    \t\ti: function intro(local) {\n    \t\t\tif (current) return;\n    \t\t\ttransition_in(chat.$$.fragment, local);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\to: function outro(local) {\n    \t\t\ttransition_out(chat.$$.fragment, local);\n    \t\t\tcurrent = false;\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tdestroy_component(chat, detaching);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tconst writable_props = [];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$capture_state = () => ({ Chat });\n    \treturn [];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, {});\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n    \t}\n    }\n\n    return Routes;\n\n})();\n",
            "dynamicImports": [],
            "fileName": "index.js",
            "implicitlyLoadedBefore": [],
            "importedBindings": {},
            "imports": [],
            "map": null,
            "referencedFiles": []
        },
        "watchFiles": [
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.css",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\svelte\\internal\\index.mjs"
        ]
    },
    "hashes": {
        "js": "adebd5740060ab85b104edd3601e49a0",
        "css": "b4a276707f65c36ac30f3ad11f80b365"
    }
}
{
    "server": {
        "component": "'use strict';\n\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nPromise.resolve();\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\n\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nvar parseuri = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n\n    return uri;\n};\n\nfunction pathNames(obj, path) {\n    var regx = /\\/{2,9}/g,\n        names = path.replace(regx, \"/\").split(\"/\");\n\n    if (path.substr(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.substr(path.length - 1, 1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n\n    return names;\n}\n\nfunction queryKey(uri, query) {\n    var data = {};\n\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n\n    return data;\n}\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parseuri(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n\nvar hasCors = {exports: {}};\n\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  hasCors.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  hasCors.exports = false;\n}\n\nvar hasCORS = hasCors.exports;\n\nvar globalThis = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n\n// browser shim for xmlhttprequest module\nfunction XMLHttpRequest$1 (opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = clearTimeout.bind(globalThis);\n    }\n}\n\n/**\n * Expose `Emitter`.\n */\n\nvar Emitter_1 = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\nconst withNativeBlob$1 = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView$1 = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob$1 && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer$2 &&\n        (data instanceof ArrayBuffer || isView$1(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + content);\n    };\n    return fileReader.readAsDataURL(data);\n};\n\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n    lookup$1[chars.charCodeAt(i$1)] = i$1;\n}\nvar decode$1 = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup$1[base64.charCodeAt(i)];\n        encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n        encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n        encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nconst withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer$1) {\n        const decoded = decode$1(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\n\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nconst protocol$1 = 4;\n\nclass Transport extends Emitter_1 {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} options.\n     * @api private\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.readyState = \"\";\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} str\n     * @return {Transport} for chaining\n     * @api protected\n     */\n    onError(msg, desc) {\n        const err = new Error(msg);\n        // @ts-ignore\n        err.type = \"TransportError\";\n        // @ts-ignore\n        err.description = desc;\n        super.emit(\"error\", err);\n        return this;\n    }\n    /**\n     * Opens the transport.\n     *\n     * @api public\n     */\n    open() {\n        if (\"closed\" === this.readyState || \"\" === this.readyState) {\n            this.readyState = \"opening\";\n            this.doOpen();\n        }\n        return this;\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api public\n     */\n    close() {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     * @api public\n     */\n    send(packets) {\n        if (\"open\" === this.readyState) {\n            this.write(packets);\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @api protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emit(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @api protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @api protected\n     */\n    onPacket(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @api protected\n     */\n    onClose() {\n        this.readyState = \"closed\";\n        super.emit(\"close\");\n    }\n}\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nvar yeast_1 = yeast;\n\nvar parseqs = {};\n\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nparseqs.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nparseqs.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n\nclass Polling extends Transport {\n    constructor() {\n        super(...arguments);\n        this.polling = false;\n    }\n    /**\n     * Transport name.\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @api private\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} callback upon buffers are flushed and transport is paused\n     * @api private\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @api public\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emit(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @api private\n     */\n    onData(data) {\n        const callback = packet => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose();\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emit(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @api private\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} data packets\n     * @param {Function} drain callback\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, data => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emit(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast_1();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = parseqs.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n}\n\n/* global attachEvent */\n/**\n * Empty function\n */\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new XMLHttpRequest$1({\n        xdomain: false\n    });\n    return null != xhr.responseType;\n})();\nclass XHR extends Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @api private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @api private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", err => {\n            this.onError(\"xhr post error\", err);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @api private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", err => {\n            this.onError(\"xhr poll error\", err);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends Emitter_1 {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @api public\n     */\n    constructor(uri, opts) {\n        super();\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @api private\n     */\n    create() {\n        const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new XMLHttpRequest$1(opts));\n        try {\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon successful response.\n     *\n     * @api private\n     */\n    onSuccess() {\n        this.emit(\"success\");\n        this.cleanup();\n    }\n    /**\n     * Called if we have data.\n     *\n     * @api private\n     */\n    onData(data) {\n        this.emit(\"data\", data);\n        this.onSuccess();\n    }\n    /**\n     * Called upon error.\n     *\n     * @api private\n     */\n    onError(err) {\n        this.emit(\"error\", err);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @api private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @api private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.onData(data);\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @api public\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n\nconst nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return cb => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nconst WebSocket = globalThis.WebSocket || globalThis.MozWebSocket;\nconst usingBrowserWebSocket = true;\nconst defaultBinaryType = \"arraybuffer\";\n\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @api {Object} connection options\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Transport name.\n     *\n     * @api public\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Opens socket.\n     *\n     * @api private\n     */\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new WebSocket(uri, protocols)\n                        : new WebSocket(uri)\n                    : new WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emit(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @api private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = this.onClose.bind(this);\n        this.ws.onmessage = ev => this.onData(ev.data);\n        this.ws.onerror = e => this.onError(\"websocket error\", e);\n    }\n    /**\n     * Writes data to socket.\n     *\n     * @param {Array} array of packets.\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, data => {\n                // always create a new object (GH-437)\n                const opts = {};\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emit(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    /**\n     * Closes socket.\n     *\n     * @api private\n     */\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast_1();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = parseqs.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @api public\n     */\n    check() {\n        return (!!WebSocket &&\n            !(\"__initialize\" in WebSocket && this.name === WS.prototype.name));\n    }\n}\n\nconst transports = {\n    websocket: WS,\n    polling: XHR\n};\n\nclass Socket$1 extends Emitter_1 {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri or options\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(uri, opts = {}) {\n        super();\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = parseuri(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parseuri(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.readyState = \"\";\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true\n        }, opts);\n        this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = parseqs.decode(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                addEventListener(\"beforeunload\", () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                }, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\");\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} transport name\n     * @return {Transport}\n     * @api private\n     */\n    createTransport(name) {\n        const query = clone(this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol$1;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port\n        });\n        return new transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @api private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket$1.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @api private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", () => {\n            this.onClose(\"transport close\");\n        });\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} transport name\n     * @api private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket$1.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", msg => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket$1.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = err => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @api private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket$1.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState &&\n            this.opts.upgrade &&\n            this.transport.pause) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @api private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @api private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @api private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            this.transport.send(this.writeBuffer);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = this.writeBuffer.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} message.\n     * @param {Function} callback function.\n     * @param {Object} options.\n     * @return {Socket} for chaining.\n     * @api public\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @api private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     *\n     * @api public\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @api private\n     */\n    onError(err) {\n        Socket$1.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @api private\n     */\n    onClose(reason, desc) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, desc);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} server upgrades\n     * @api private\n     *\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket$1.protocol = protocol$1;\nfunction clone(obj) {\n    const o = {};\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            o[i] = obj[i];\n        }\n    }\n    return o;\n}\n\nSocket$1.protocol;\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    packet.attachments = undefined; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder) {\n        return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n\n/**\n * Protocol version.\n *\n * @public\n */\nconst protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (hasBinary(obj)) {\n                obj.type =\n                    obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK;\n                return this.encodeAsBinary(obj);\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends Emitter_1 {\n    constructor() {\n        super();\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            packet = this.decodeString(obj);\n            if (packet.type === PacketType.BINARY_EVENT ||\n                packet.type === PacketType.BINARY_ACK) {\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n        }\n    }\n}\nfunction tryParse(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n\nvar parser = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    protocol: protocol,\n    get PacketType () { return PacketType; },\n    Encoder: Encoder,\n    Decoder: Decoder\n});\n\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nclass Socket extends Emitter_1 {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.connected = false;\n        this.disconnected = true;\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            this.acks[this.ids] = args.pop();\n            packet.id = this.ids++;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) ;\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n                this.onack(packet);\n                break;\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\n\n/**\n * Expose `Backoff`.\n */\n\nvar backo2 = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\nclass Manager extends Emitter_1 {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new backo2({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Socket$1(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on(socket, \"error\", (err) => {\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        this.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        if (\"opening\" === this._readyState) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n\n/* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\nconst css$1 = {\n\tcode: \"@import url(\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\");h1.svelte-127bm7n.svelte-127bm7n{margin:0 auto;margin-top:1em;font-size:64px;color:#FFFFFF}.chat-view.svelte-127bm7n.svelte-127bm7n{background:#FCFCFC;border-radius:8px;width:100%;height:80%;margin-bottom:2em;box-shadow:0px 6px 6px rgba(0, 0, 0, 0.24);overflow-x:hidden;overflow-y:scroll;scrollbar-color:#dfdfdf #f8f8f8}.client-message.svelte-127bm7n.svelte-127bm7n{background:#e4f4f7;width:90%;min-height:10%;margin:0 auto;margin-top:1em;margin-left:1.6em;border-top-right-radius:4px;border-top-left-radius:0;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:0.4em}.client-message.svelte-127bm7n.svelte-127bm7n::before{content:\\\"\\\";top:-0.4em;left:-1.4em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #e4f4f7;border-left:20px solid transparent}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even){background:#1E88E5;border-top-right-radius:0;border-top-left-radius:4px;border-bottom-left-radius:4px;border-bottom-right-radius:4px;margin:0 auto;margin-top:1em;margin-right:1.6em}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even)::before{content:\\\"\\\";top:-0.4em;left:47.6em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #1E88E5;border-left:20px solid transparent;transform:rotateY(180deg)}h4.svelte-127bm7n.svelte-127bm7n{font-size:1.4em}p.svelte-127bm7n.svelte-127bm7n{font-size:1.2em}.client-message.svelte-127bm7n h4.svelte-127bm7n{margin:0;margin-bottom:0.2em;position:relative;top:-1.6em;left:0.4em}.client-message.svelte-127bm7n:nth-child(even) h4.svelte-127bm7n{position:relative;left:30em}.client-message.svelte-127bm7n p.svelte-127bm7n{margin:0;position:relative;top:-2em;padding-right:6em;padding-left:0.5em}.client-message.svelte-127bm7n:nth-child(even) p.svelte-127bm7n{position:relative;padding-left:6em;padding-right:0.5em}.message-box.svelte-127bm7n.svelte-127bm7n{display:flex;flex-direction:row;background:#FCFCFC;border-radius:8px;width:100%;height:6em;box-shadow:0px 6px 6px rgba(0, 0, 0, 0.24)}.message-box.svelte-127bm7n fieldset.svelte-127bm7n{border:2px solid #d7e3e4;border-radius:8px;background:#EBF8FA;width:90%;height:70%;margin:0.3em;font-size:1.4em;padding:0.3em}.message-box.svelte-127bm7n svg.svelte-127bm7n{margin-left:1em;margin-right:1.4em;margin-top:1.4em;cursor:pointer}@media screen and (min-width: 1026px){.chat-view.svelte-127bm7n.svelte-127bm7n{height:58%}.client-message.svelte-127bm7n.svelte-127bm7n{width:80%}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even)::before{content:\\\"\\\";top:-0.4em;left:55em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #1E88E5;border-left:20px solid transparent;transform:rotateY(180deg)}.client-message.svelte-127bm7n:nth-child(even) h4.svelte-127bm7n{position:relative;left:35em}}\",\n\tmap: \"{\\\"version\\\":3,\\\"file\\\":\\\"chat.svelte\\\",\\\"sources\\\":[\\\"chat.svelte\\\"],\\\"sourcesContent\\\":[\\\"<script>\\\\r\\\\n    import { io } from \\\\\\\"socket.io-client\\\\\\\";\\\\r\\\\n    const socket = io(\\\\\\\"localhost:3002\\\\\\\");\\\\r\\\\n\\\\r\\\\n    export let chatHistory = [];\\\\r\\\\n\\\\r\\\\n    // Client socket callback that occurs on connection to server. \\\\r\\\\n    socket.on(\\\\\\\"connect\\\\\\\", () => {\\\\r\\\\n        // either with send()  socket.send(\\\\\\\"Hello!\\\\\\\");\\\\r\\\\n        // or with emit() and custom event names \\\\r\\\\n        //let clientConnected = `CLIENT connected from ...`;\\\\r\\\\n        //socket.emit(\\\\\\\"clientConnect\\\\\\\", clientConnected);\\\\r\\\\n        console.log(\\\\\\\"Connected to server\\\\\\\");\\\\r\\\\n\\\\r\\\\n        // Client socket listening to specific key emit from server socket\\\\r\\\\n        socket.on(\\\\\\\"serverMessage\\\\\\\", (user, msg) => {\\\\r\\\\n            AddMessage(user, msg);\\\\r\\\\n            // Force update so reactivity works\\\\r\\\\n            chatHistory = chatHistory;\\\\r\\\\n        });\\\\r\\\\n    });\\\\r\\\\n\\\\r\\\\n    const AddMessage = (user, msg) => {\\\\r\\\\n        let chatObj = {\\\\r\\\\n            user,\\\\r\\\\n            msg\\\\r\\\\n        };\\\\r\\\\n        chatHistory.push(chatObj);\\\\r\\\\n        // Clientside logging\\\\r\\\\n        console.log(\\\\\\\"Client Message: \\\\\\\" + msg);\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    let username = \\\\\\\"Guest\\\\\\\";\\\\r\\\\n    let newMessage = \\\\\\\"\\\\\\\";\\\\r\\\\n\\\\r\\\\n    /* Example request for a server emit\\\\r\\\\n    const TestData = async() => {\\\\r\\\\n        let response = await fetch(\\\\\\\"/test\\\\\\\");\\\\r\\\\n        if(!response.ok) return console.error(\\\\\\\"ERROR FETCH\\\\\\\");\\\\r\\\\n    }\\\\r\\\\n    */\\\\r\\\\n\\\\r\\\\n   //socket.emit(\\\\\\\"clientMessage\\\\\\\", newMessage);\\\\r\\\\n    const SendMessage = async() => {\\\\r\\\\n        let msgObj = {\\\\r\\\\n            username,\\\\r\\\\n            newMessage\\\\r\\\\n        };\\\\r\\\\n\\\\r\\\\n        let response = await fetch(\\\\\\\"/chat/message\\\\\\\", {\\\\r\\\\n            method: \\\\\\\"POST\\\\\\\",\\\\r\\\\n            headers: {\\\\r\\\\n                \\\\\\\"Content-Type\\\\\\\": \\\\\\\"application/json;charset=utf-8\\\\\\\"\\\\r\\\\n            },\\\\r\\\\n            body: JSON.stringify(msgObj)\\\\r\\\\n        });\\\\r\\\\n\\\\r\\\\n        if(!response.ok) return console.error(\\\\\\\"Could not send message!\\\\\\\");\\\\r\\\\n\\\\r\\\\n        let result = response.text();\\\\r\\\\n        //console.log(result);\\\\r\\\\n    }\\\\r\\\\n\\\\r\\\\n    // Reactively update the client-message fields\\\\r\\\\n    $: chatHistory;\\\\r\\\\n</script>\\\\r\\\\n\\\\r\\\\n<style>@import url(\\\\\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\\\\\");\\\\nh1 {\\\\n  margin: 0 auto;\\\\n  margin-top: 1em;\\\\n  font-size: 64px;\\\\n  color: #FFFFFF;\\\\n}\\\\n\\\\n.chat-view {\\\\n  background: #FCFCFC;\\\\n  border-radius: 8px;\\\\n  width: 100%;\\\\n  height: 80%;\\\\n  margin-bottom: 2em;\\\\n  box-shadow: 0px 6px 6px rgba(0, 0, 0, 0.24);\\\\n  overflow-x: hidden;\\\\n  overflow-y: scroll;\\\\n  scrollbar-color: #dfdfdf #f8f8f8;\\\\n}\\\\n\\\\n.client-message {\\\\n  background: #e4f4f7;\\\\n  width: 90%;\\\\n  min-height: 10%;\\\\n  margin: 0 auto;\\\\n  margin-top: 1em;\\\\n  margin-left: 1.6em;\\\\n  border-top-right-radius: 4px;\\\\n  border-top-left-radius: 0;\\\\n  border-bottom-left-radius: 4px;\\\\n  border-bottom-right-radius: 4px;\\\\n  padding: 0.4em;\\\\n}\\\\n\\\\n.client-message::before {\\\\n  content: \\\\\\\"\\\\\\\";\\\\n  top: -0.4em;\\\\n  left: -1.4em;\\\\n  position: relative;\\\\n  display: block;\\\\n  width: 2em;\\\\n  height: 1em;\\\\n  background-color: transparent;\\\\n  border-top: 20px solid #e4f4f7;\\\\n  border-left: 20px solid transparent;\\\\n}\\\\n\\\\n.client-message:nth-child(even) {\\\\n  background: #1E88E5;\\\\n  border-top-right-radius: 0;\\\\n  border-top-left-radius: 4px;\\\\n  border-bottom-left-radius: 4px;\\\\n  border-bottom-right-radius: 4px;\\\\n  margin: 0 auto;\\\\n  margin-top: 1em;\\\\n  margin-right: 1.6em;\\\\n}\\\\n\\\\n.client-message:nth-child(even)::before {\\\\n  content: \\\\\\\"\\\\\\\";\\\\n  top: -0.4em;\\\\n  left: 47.6em;\\\\n  position: relative;\\\\n  display: block;\\\\n  width: 2em;\\\\n  height: 1em;\\\\n  background-color: transparent;\\\\n  border-top: 20px solid #1E88E5;\\\\n  border-left: 20px solid transparent;\\\\n  transform: rotateY(180deg);\\\\n}\\\\n\\\\nh4 {\\\\n  font-size: 1.4em;\\\\n}\\\\n\\\\np {\\\\n  font-size: 1.2em;\\\\n}\\\\n\\\\n.client-message h4 {\\\\n  margin: 0;\\\\n  margin-bottom: 0.2em;\\\\n  position: relative;\\\\n  top: -1.6em;\\\\n  left: 0.4em;\\\\n}\\\\n\\\\n.client-message:nth-child(even) h4 {\\\\n  position: relative;\\\\n  left: 30em;\\\\n}\\\\n\\\\n.client-message p {\\\\n  margin: 0;\\\\n  position: relative;\\\\n  top: -2em;\\\\n  padding-right: 6em;\\\\n  padding-left: 0.5em;\\\\n}\\\\n\\\\n.client-message:nth-child(even) p {\\\\n  position: relative;\\\\n  padding-left: 6em;\\\\n  padding-right: 0.5em;\\\\n}\\\\n\\\\n.message-box {\\\\n  display: flex;\\\\n  flex-direction: row;\\\\n  background: #FCFCFC;\\\\n  border-radius: 8px;\\\\n  width: 100%;\\\\n  height: 6em;\\\\n  box-shadow: 0px 6px 6px rgba(0, 0, 0, 0.24);\\\\n}\\\\n\\\\n.message-box fieldset {\\\\n  border: 2px solid #d7e3e4;\\\\n  border-radius: 8px;\\\\n  background: #EBF8FA;\\\\n  width: 90%;\\\\n  height: 70%;\\\\n  margin: 0.3em;\\\\n  font-size: 1.4em;\\\\n  padding: 0.3em;\\\\n}\\\\n\\\\n.message-box svg {\\\\n  margin-left: 1em;\\\\n  margin-right: 1.4em;\\\\n  margin-top: 1.4em;\\\\n  cursor: pointer;\\\\n}\\\\n\\\\n/* RESPONSIVENESS */\\\\n/* Desktop */\\\\n@media screen and (min-width: 1026px) {\\\\n  .chat-view {\\\\n    height: 58%;\\\\n  }\\\\n\\\\n  .client-message {\\\\n    width: 80%;\\\\n  }\\\\n\\\\n  .client-message:nth-child(even)::before {\\\\n    content: \\\\\\\"\\\\\\\";\\\\n    top: -0.4em;\\\\n    left: 55em;\\\\n    position: relative;\\\\n    display: block;\\\\n    width: 2em;\\\\n    height: 1em;\\\\n    background-color: transparent;\\\\n    border-top: 20px solid #1E88E5;\\\\n    border-left: 20px solid transparent;\\\\n    transform: rotateY(180deg);\\\\n  }\\\\n\\\\n  .client-message:nth-child(even) h4 {\\\\n    position: relative;\\\\n    left: 35em;\\\\n  }\\\\n}</style>\\\\r\\\\n\\\\r\\\\n<h1>CHAT</h1>\\\\r\\\\n\\\\r\\\\n<div class=\\\\\\\"chat-view\\\\\\\">\\\\r\\\\n    {#each chatHistory as chatMessage, i}\\\\r\\\\n        <div class=\\\\\\\"client-message\\\\\\\">\\\\r\\\\n            <h4>{chatMessage.user}</h4>\\\\r\\\\n            <p>{chatMessage.msg}</p>\\\\r\\\\n        </div>\\\\r\\\\n    {/each}\\\\r\\\\n</div>\\\\r\\\\n\\\\r\\\\n<div class=\\\\\\\"message-box\\\\\\\">\\\\r\\\\n    <fieldset contenteditable=\\\\\\\"true\\\\\\\" bind:textContent={newMessage} />\\\\r\\\\n    <svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" width=\\\\\\\"49.369\\\\\\\" height=\\\\\\\"49.384\\\\\\\" viewBox=\\\\\\\"0 0 49.369 49.384\\\\\\\" on:click={() => SendMessage()}>\\\\r\\\\n        <path id=\\\\\\\"Path_3\\\\\\\" data-name=\\\\\\\"Path 3\\\\\\\" d=\\\\\\\"M45.912.281,1.215,26.067a2.316,2.316,0,0,0,.212,4.166l10.251,4.3L39.383,10.117a.578.578,0,0,1,.829.8l-23.231,28.3v7.763a2.314,2.314,0,0,0,4.1,1.524L27.2,41.053l12.016,5.034A2.321,2.321,0,0,0,42.4,44.332L49.345,2.672A2.315,2.315,0,0,0,45.912.281Z\\\\\\\" transform=\\\\\\\"translate(-0.01 0.031)\\\\\\\" fill=\\\\\\\"#1e88e5\\\\\\\"/>\\\\r\\\\n    </svg>      \\\\r\\\\n</div>\\\\r\\\\n\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\"AAmEO,QAAQ,IAAI,sEAAsE,CAAC,CAAC,AAC3F,EAAE,8BAAC,CAAC,AACF,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,GAAG,CACf,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,AAChB,CAAC,AAED,UAAU,8BAAC,CAAC,AACV,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CACX,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAC3C,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,MAAM,CAClB,eAAe,CAAE,OAAO,CAAC,OAAO,AAClC,CAAC,AAED,eAAe,8BAAC,CAAC,AACf,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,GAAG,CACV,UAAU,CAAE,GAAG,CACf,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,GAAG,CACf,WAAW,CAAE,KAAK,CAClB,uBAAuB,CAAE,GAAG,CAC5B,sBAAsB,CAAE,CAAC,CACzB,yBAAyB,CAAE,GAAG,CAC9B,0BAA0B,CAAE,GAAG,CAC/B,OAAO,CAAE,KAAK,AAChB,CAAC,AAED,6CAAe,QAAQ,AAAC,CAAC,AACvB,OAAO,CAAE,EAAE,CACX,GAAG,CAAE,MAAM,CACX,IAAI,CAAE,MAAM,CACZ,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,gBAAgB,CAAE,WAAW,CAC7B,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAC9B,WAAW,CAAE,IAAI,CAAC,KAAK,CAAC,WAAW,AACrC,CAAC,AAED,6CAAe,WAAW,IAAI,CAAC,AAAC,CAAC,AAC/B,UAAU,CAAE,OAAO,CACnB,uBAAuB,CAAE,CAAC,CAC1B,sBAAsB,CAAE,GAAG,CAC3B,yBAAyB,CAAE,GAAG,CAC9B,0BAA0B,CAAE,GAAG,CAC/B,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,GAAG,CACf,YAAY,CAAE,KAAK,AACrB,CAAC,AAED,6CAAe,WAAW,IAAI,CAAC,QAAQ,AAAC,CAAC,AACvC,OAAO,CAAE,EAAE,CACX,GAAG,CAAE,MAAM,CACX,IAAI,CAAE,MAAM,CACZ,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,gBAAgB,CAAE,WAAW,CAC7B,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAC9B,WAAW,CAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CACnC,SAAS,CAAE,QAAQ,MAAM,CAAC,AAC5B,CAAC,AAED,EAAE,8BAAC,CAAC,AACF,SAAS,CAAE,KAAK,AAClB,CAAC,AAED,CAAC,8BAAC,CAAC,AACD,SAAS,CAAE,KAAK,AAClB,CAAC,AAED,8BAAe,CAAC,EAAE,eAAC,CAAC,AAClB,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,KAAK,CACpB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,MAAM,CACX,IAAI,CAAE,KAAK,AACb,CAAC,AAED,8BAAe,WAAW,IAAI,CAAC,CAAC,EAAE,eAAC,CAAC,AAClC,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,AACZ,CAAC,AAED,8BAAe,CAAC,CAAC,eAAC,CAAC,AACjB,MAAM,CAAE,CAAC,CACT,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,aAAa,CAAE,GAAG,CAClB,YAAY,CAAE,KAAK,AACrB,CAAC,AAED,8BAAe,WAAW,IAAI,CAAC,CAAC,CAAC,eAAC,CAAC,AACjC,QAAQ,CAAE,QAAQ,CAClB,YAAY,CAAE,GAAG,CACjB,aAAa,CAAE,KAAK,AACtB,CAAC,AAED,YAAY,8BAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,UAAU,CAAE,OAAO,CACnB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,AAC7C,CAAC,AAED,2BAAY,CAAC,QAAQ,eAAC,CAAC,AACrB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CACzB,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,KAAK,CAChB,OAAO,CAAE,KAAK,AAChB,CAAC,AAED,2BAAY,CAAC,GAAG,eAAC,CAAC,AAChB,WAAW,CAAE,GAAG,CAChB,YAAY,CAAE,KAAK,CACnB,UAAU,CAAE,KAAK,CACjB,MAAM,CAAE,OAAO,AACjB,CAAC,AAID,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AACrC,UAAU,8BAAC,CAAC,AACV,MAAM,CAAE,GAAG,AACb,CAAC,AAED,eAAe,8BAAC,CAAC,AACf,KAAK,CAAE,GAAG,AACZ,CAAC,AAED,6CAAe,WAAW,IAAI,CAAC,QAAQ,AAAC,CAAC,AACvC,OAAO,CAAE,EAAE,CACX,GAAG,CAAE,MAAM,CACX,IAAI,CAAE,IAAI,CACV,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,KAAK,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,gBAAgB,CAAE,WAAW,CAC7B,UAAU,CAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAC9B,WAAW,CAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CACnC,SAAS,CAAE,QAAQ,MAAM,CAAC,AAC5B,CAAC,AAED,8BAAe,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,eAAC,CAAC,AAClC,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,IAAI,AACZ,CAAC,AACH,CAAC\\\"}\"\n};\n\nconst Chat = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tconst socket = lookup(\"localhost:3002\");\n\tlet { chatHistory = [] } = $$props;\n\n\t// Client socket callback that occurs on connection to server. \n\tsocket.on(\"connect\", () => {\n\t\t// either with send()  socket.send(\"Hello!\");\n\t\t// or with emit() and custom event names \n\t\t//let clientConnected = `CLIENT connected from ...`;\n\t\t//socket.emit(\"clientConnect\", clientConnected);\n\t\tconsole.log(\"Connected to server\");\n\n\t\t// Client socket listening to specific key emit from server socket\n\t\tsocket.on(\"serverMessage\", (user, msg) => {\n\t\t\tAddMessage(user, msg);\n\n\t\t\t// Force update so reactivity works\n\t\t\tchatHistory = chatHistory;\n\t\t});\n\t});\n\n\tconst AddMessage = (user, msg) => {\n\t\tlet chatObj = { user, msg };\n\t\tchatHistory.push(chatObj);\n\n\t\t// Clientside logging\n\t\tconsole.log(\"Client Message: \" + msg);\n\t};\n\tlet newMessage = \"\";\n\n\tif ($$props.chatHistory === void 0 && $$bindings.chatHistory && chatHistory !== void 0) $$bindings.chatHistory(chatHistory);\n\t$$result.css.add(css$1);\n\n\treturn `<h1 class=\"${\"svelte-127bm7n\"}\">CHAT</h1>\r\n\r\n<div class=\"${\"chat-view svelte-127bm7n\"}\">${each(chatHistory, (chatMessage, i) => `<div class=\"${\"client-message svelte-127bm7n\"}\"><h4 class=\"${\"svelte-127bm7n\"}\">${escape(chatMessage.user)}</h4>\r\n            <p class=\"${\"svelte-127bm7n\"}\">${escape(chatMessage.msg)}</p>\r\n        </div>`)}</div>\r\n\r\n<div class=\"${\"message-box svelte-127bm7n\"}\"><fieldset contenteditable=\"${\"true\"}\" class=\"${\"svelte-127bm7n\"}\">${($$value => $$value === void 0 ? `` : $$value)(newMessage)}</fieldset>\r\n    <svg xmlns=\"${\"http://www.w3.org/2000/svg\"}\" width=\"${\"49.369\"}\" height=\"${\"49.384\"}\" viewBox=\"${\"0 0 49.369 49.384\"}\" class=\"${\"svelte-127bm7n\"}\"><path id=\"${\"Path_3\"}\" data-name=\"${\"Path 3\"}\" d=\"${\"M45.912.281,1.215,26.067a2.316,2.316,0,0,0,.212,4.166l10.251,4.3L39.383,10.117a.578.578,0,0,1,.829.8l-23.231,28.3v7.763a2.314,2.314,0,0,0,4.1,1.524L27.2,41.053l12.016,5.034A2.321,2.321,0,0,0,42.4,44.332L49.345,2.672A2.315,2.315,0,0,0,45.912.281Z\"}\" transform=\"${\"translate(-0.01 0.031)\"}\" fill=\"${\"#1e88e5\"}\"></path></svg></div>`;\n});\n\n/* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n\nconst css = {\n\tcode: \"@import url(\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\");main.svelte-1w3n4eh.svelte-1w3n4eh{margin:0 auto;width:90%;height:90vh;display:flex;flex-direction:column;font-size:16px;font-family:\\\"Rubik\\\"}footer.svelte-1w3n4eh.svelte-1w3n4eh{background:#00897B;height:10vh;color:#EFEFEF;text-align:center;padding-top:3em;font-size:2em}footer.svelte-1w3n4eh a.svelte-1w3n4eh{text-decoration:none;color:#EFEFEF}@media screen and (min-width: 1026px){main.svelte-1w3n4eh.svelte-1w3n4eh{width:60%}footer.svelte-1w3n4eh.svelte-1w3n4eh{background:#00897B;height:10vh;color:#EFEFEF;text-align:center;padding-top:1.4em;font-size:1.4em}}\",\n\tmap: \"{\\\"version\\\":3,\\\"file\\\":\\\"index.svelte\\\",\\\"sources\\\":[\\\"index.svelte\\\"],\\\"sourcesContent\\\":[\\\"<script>\\\\r\\\\n    import Chat from \\\\\\\"../components/chat.svelte\\\\\\\";\\\\r\\\\n    export let chatHistory = [];\\\\r\\\\n</script>\\\\r\\\\n\\\\r\\\\n<style>@import url(\\\\\\\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\\\\\\\");\\\\nmain {\\\\n  margin: 0 auto;\\\\n  width: 90%;\\\\n  height: 90vh;\\\\n  display: flex;\\\\n  flex-direction: column;\\\\n  font-size: 16px;\\\\n  font-family: \\\\\\\"Rubik\\\\\\\";\\\\n}\\\\n\\\\nfooter {\\\\n  background: #00897B;\\\\n  height: 10vh;\\\\n  color: #EFEFEF;\\\\n  text-align: center;\\\\n  padding-top: 3em;\\\\n  font-size: 2em;\\\\n}\\\\n\\\\nfooter a {\\\\n  text-decoration: none;\\\\n  color: #EFEFEF;\\\\n}\\\\n\\\\n/* RESPONSIVENESS */\\\\n/* Desktop */\\\\n@media screen and (min-width: 1026px) {\\\\n  main {\\\\n    width: 60%;\\\\n  }\\\\n\\\\n  footer {\\\\n    background: #00897B;\\\\n    height: 10vh;\\\\n    color: #EFEFEF;\\\\n    text-align: center;\\\\n    padding-top: 1.4em;\\\\n    font-size: 1.4em;\\\\n  }\\\\n}</style>\\\\r\\\\n\\\\r\\\\n<main>\\\\r\\\\n    <Chat {chatHistory}/>\\\\r\\\\n</main>\\\\r\\\\n<footer>\\\\r\\\\n    Copyright 2021 - <a href=\\\\\\\"https://ignurof.xyz\\\\\\\" target=\\\\\\\"_blank\\\\\\\">ignurof.xyz</a>\\\\r\\\\n</footer>\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\"AAKO,QAAQ,IAAI,sEAAsE,CAAC,CAAC,AAC3F,IAAI,8BAAC,CAAC,AACJ,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,OAAO,AACtB,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,UAAU,CAAE,OAAO,CACnB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,GAAG,CAChB,SAAS,CAAE,GAAG,AAChB,CAAC,AAED,qBAAM,CAAC,CAAC,eAAC,CAAC,AACR,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,OAAO,AAChB,CAAC,AAID,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC,AAAC,CAAC,AACrC,IAAI,8BAAC,CAAC,AACJ,KAAK,CAAE,GAAG,AACZ,CAAC,AAED,MAAM,8BAAC,CAAC,AACN,UAAU,CAAE,OAAO,CACnB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,KAAK,CAClB,SAAS,CAAE,KAAK,AAClB,CAAC,AACH,CAAC\\\"}\"\n};\n\nconst Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet { chatHistory = [] } = $$props;\n\tif ($$props.chatHistory === void 0 && $$bindings.chatHistory && chatHistory !== void 0) $$bindings.chatHistory(chatHistory);\n\t$$result.css.add(css);\n\n\treturn `<main class=\"${\"svelte-1w3n4eh\"}\">${validate_component(Chat, \"Chat\").$$render($$result, { chatHistory }, {}, {})}</main>\r\n<footer class=\"${\"svelte-1w3n4eh\"}\">Copyright 2021 - <a href=\"${\"https://ignurof.xyz\"}\" target=\"${\"_blank\"}\" class=\"${\"svelte-1w3n4eh\"}\">ignurof.xyz</a></footer>`;\n});\n\nmodule.exports = Routes;\n",
        "css": "@import url(\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\");main.svelte-1w3n4eh.svelte-1w3n4eh{margin:0 auto;width:90%;height:90vh;display:flex;flex-direction:column;font-size:16px;font-family:\"Rubik\"}footer.svelte-1w3n4eh.svelte-1w3n4eh{background:#00897B;height:10vh;color:#EFEFEF;text-align:center;padding-top:3em;font-size:2em}footer.svelte-1w3n4eh a.svelte-1w3n4eh{text-decoration:none;color:#EFEFEF}@media screen and (min-width: 1026px){main.svelte-1w3n4eh.svelte-1w3n4eh{width:60%}footer.svelte-1w3n4eh.svelte-1w3n4eh{background:#00897B;height:10vh;color:#EFEFEF;text-align:center;padding-top:1.4em;font-size:1.4em}}@import url(\"https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap\");h1.svelte-127bm7n.svelte-127bm7n{margin:0 auto;margin-top:1em;font-size:64px;color:#FFFFFF}.chat-view.svelte-127bm7n.svelte-127bm7n{background:#FCFCFC;border-radius:8px;width:100%;height:80%;margin-bottom:2em;box-shadow:0px 6px 6px rgba(0, 0, 0, 0.24);overflow-x:hidden;overflow-y:scroll;scrollbar-color:#dfdfdf #f8f8f8}.client-message.svelte-127bm7n.svelte-127bm7n{background:#e4f4f7;width:90%;min-height:10%;margin:0 auto;margin-top:1em;margin-left:1.6em;border-top-right-radius:4px;border-top-left-radius:0;border-bottom-left-radius:4px;border-bottom-right-radius:4px;padding:0.4em}.client-message.svelte-127bm7n.svelte-127bm7n::before{content:\"\";top:-0.4em;left:-1.4em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #e4f4f7;border-left:20px solid transparent}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even){background:#1E88E5;border-top-right-radius:0;border-top-left-radius:4px;border-bottom-left-radius:4px;border-bottom-right-radius:4px;margin:0 auto;margin-top:1em;margin-right:1.6em}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even)::before{content:\"\";top:-0.4em;left:47.6em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #1E88E5;border-left:20px solid transparent;transform:rotateY(180deg)}h4.svelte-127bm7n.svelte-127bm7n{font-size:1.4em}p.svelte-127bm7n.svelte-127bm7n{font-size:1.2em}.client-message.svelte-127bm7n h4.svelte-127bm7n{margin:0;margin-bottom:0.2em;position:relative;top:-1.6em;left:0.4em}.client-message.svelte-127bm7n:nth-child(even) h4.svelte-127bm7n{position:relative;left:30em}.client-message.svelte-127bm7n p.svelte-127bm7n{margin:0;position:relative;top:-2em;padding-right:6em;padding-left:0.5em}.client-message.svelte-127bm7n:nth-child(even) p.svelte-127bm7n{position:relative;padding-left:6em;padding-right:0.5em}.message-box.svelte-127bm7n.svelte-127bm7n{display:flex;flex-direction:row;background:#FCFCFC;border-radius:8px;width:100%;height:6em;box-shadow:0px 6px 6px rgba(0, 0, 0, 0.24)}.message-box.svelte-127bm7n fieldset.svelte-127bm7n{border:2px solid #d7e3e4;border-radius:8px;background:#EBF8FA;width:90%;height:70%;margin:0.3em;font-size:1.4em;padding:0.3em}.message-box.svelte-127bm7n svg.svelte-127bm7n{margin-left:1em;margin-right:1.4em;margin-top:1.4em;cursor:pointer}@media screen and (min-width: 1026px){.chat-view.svelte-127bm7n.svelte-127bm7n{height:58%}.client-message.svelte-127bm7n.svelte-127bm7n{width:80%}.client-message.svelte-127bm7n.svelte-127bm7n:nth-child(even)::before{content:\"\";top:-0.4em;left:55em;position:relative;display:block;width:2em;height:1em;background-color:transparent;border-top:20px solid #1E88E5;border-left:20px solid transparent;transform:rotateY(180deg)}.client-message.svelte-127bm7n:nth-child(even) h4.svelte-127bm7n{position:relative;left:35em}}"
    },
    "client": {
        "js": {
            "exports": [
                "default"
            ],
            "facadeModuleId": "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte",
            "isDynamicEntry": false,
            "isEntry": true,
            "isImplicitEntry": false,
            "modules": {
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\svelte\\internal\\index.mjs": {
                    "code": "    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function destroy_each(iterations, detaching) {\n        for (let i = 0; i < iterations.length; i += 1) {\n            if (iterations[i])\n                iterations[i].d(detaching);\n        }\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function svg_element(name) {\n        return document.createElementNS('http://www.w3.org/2000/svg', name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function listen(node, event, handler, options) {\n        node.addEventListener(event, handler, options);\n        return () => node.removeEventListener(event, handler, options);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_svg_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, svg_element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    let outros;\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function transition_out(block, local, detach, callback) {\n        if (block && block.o) {\n            if (outroing.has(block))\n                return;\n            outroing.add(block);\n            outros.c.push(() => {\n                outroing.delete(block);\n                if (callback) {\n                    if (detach)\n                        block.d(1);\n                    callback();\n                }\n            });\n            block.o(local);\n        }\n    }\n\n    const globals = (typeof window !== 'undefined'\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : global);\n    function create_component(block) {\n        block && block.c();\n    }\n    function claim_component(block, parent_nodes) {\n        block && block.l(parent_nodes);\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n        if (has_prevent_default)\n            modifiers.push('preventDefault');\n        if (has_stop_propagation)\n            modifiers.push('stopPropagation');\n        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n        const dispose = listen(node, event, handler, options);\n        return () => {\n            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n            dispose();\n        };\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function set_data_dev(text, data) {\n        data = '' + data;\n        if (text.wholeText === data)\n            return;\n        dispatch_dev('SvelteDOMSetData', { node: text, data });\n        text.data = data;\n    }\n    function validate_each_argument(arg) {\n        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n            let msg = '{#each} only iterates over array-like objects.';\n            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n                msg += ' You can use a spread to convert this iterable into an array.';\n            }\n            throw new Error(msg);\n        }\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }",
                    "originalLength": 67632,
                    "removedExports": [
                        "HtmlTag",
                        "HtmlTagHydration",
                        "SvelteComponentTyped",
                        "SvelteElement",
                        "action_destroyer",
                        "add_attribute",
                        "add_classes",
                        "add_flush_callback",
                        "add_resize_listener",
                        "add_transform",
                        "afterUpdate",
                        "append",
                        "append_dev",
                        "append_empty_stylesheet",
                        "append_styles",
                        "assign",
                        "attribute_to_object",
                        "beforeUpdate",
                        "bind",
                        "bubble",
                        "check_outros",
                        "claim_html_tag",
                        "clear_loops",
                        "component_subscribe",
                        "compute_rest_props",
                        "compute_slots",
                        "createEventDispatcher",
                        "create_animation",
                        "create_bidirectional_transition",
                        "create_in_transition",
                        "create_out_transition",
                        "create_slot",
                        "create_ssr_component",
                        "dataset_dev",
                        "debug",
                        "destroy_block",
                        "detach_after_dev",
                        "detach_before_dev",
                        "detach_between_dev",
                        "each",
                        "element_is",
                        "empty",
                        "escape",
                        "escape_attribute_value",
                        "escape_object",
                        "escaped",
                        "exclude_internal_props",
                        "fix_and_destroy_block",
                        "fix_and_outro_and_destroy_block",
                        "fix_position",
                        "getAllContexts",
                        "getContext",
                        "get_all_dirty_from_scope",
                        "get_binding_group_value",
                        "get_current_component",
                        "get_custom_elements_slots",
                        "get_root_for_style",
                        "get_slot_changes",
                        "get_spread_object",
                        "get_spread_update",
                        "get_store_value",
                        "group_outros",
                        "handle_promise",
                        "hasContext",
                        "has_prop",
                        "identity",
                        "insert",
                        "insert_dev",
                        "intros",
                        "invalid_attribute_name_character",
                        "is_client",
                        "is_crossorigin",
                        "is_promise",
                        "loop",
                        "loop_guard",
                        "missing_component",
                        "not_equal",
                        "now",
                        "null_to_empty",
                        "object_without_properties",
                        "onDestroy",
                        "onMount",
                        "once",
                        "outro_and_destroy_block",
                        "prevent_default",
                        "prop_dev",
                        "query_selector_all",
                        "raf",
                        "select_multiple_value",
                        "select_option",
                        "select_options",
                        "select_value",
                        "self",
                        "setContext",
                        "set_attributes",
                        "set_custom_element_data",
                        "set_data",
                        "set_input_type",
                        "set_input_value",
                        "set_now",
                        "set_raf",
                        "set_store_value",
                        "set_style",
                        "set_svg_attributes",
                        "spread",
                        "src_url_equal",
                        "stop_propagation",
                        "subscribe",
                        "tick",
                        "time_ranges_to_array",
                        "to_number",
                        "toggle_class",
                        "trusted",
                        "update_await_block_branch",
                        "update_keyed_each",
                        "update_slot",
                        "update_slot_base",
                        "validate_component",
                        "validate_each_keys",
                        "validate_store",
                        "xlink_attr"
                    ],
                    "renderedExports": [
                        "SvelteComponent",
                        "SvelteComponentDev",
                        "add_location",
                        "add_render_callback",
                        "append_hydration",
                        "append_hydration_dev",
                        "attr",
                        "attr_dev",
                        "binding_callbacks",
                        "blank_object",
                        "children",
                        "claim_component",
                        "claim_element",
                        "claim_space",
                        "claim_svg_element",
                        "claim_text",
                        "create_component",
                        "current_component",
                        "custom_event",
                        "destroy_component",
                        "destroy_each",
                        "detach",
                        "detach_dev",
                        "dirty_components",
                        "dispatch_dev",
                        "element",
                        "end_hydrating",
                        "flush",
                        "globals",
                        "init",
                        "insert_hydration",
                        "insert_hydration_dev",
                        "is_empty",
                        "is_function",
                        "listen",
                        "listen_dev",
                        "mount_component",
                        "noop",
                        "run",
                        "run_all",
                        "safe_not_equal",
                        "schedule_update",
                        "set_current_component",
                        "set_data_dev",
                        "space",
                        "start_hydrating",
                        "svg_element",
                        "text",
                        "transition_in",
                        "transition_out",
                        "validate_each_argument",
                        "validate_slots"
                    ],
                    "renderedLength": 20840
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseuri\\index.js": {
                    "code": "    /**\n     * Parses an URI\n     *\n     * @author Steven Levithan <stevenlevithan.com> (MIT license)\n     * @api private\n     */\n\n    var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n    var parts = [\n        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n    ];\n\n    var parseuri = function parseuri(str) {\n        var src = str,\n            b = str.indexOf('['),\n            e = str.indexOf(']');\n\n        if (b != -1 && e != -1) {\n            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n        }\n\n        var m = re.exec(str || ''),\n            uri = {},\n            i = 14;\n\n        while (i--) {\n            uri[parts[i]] = m[i] || '';\n        }\n\n        if (b != -1 && e != -1) {\n            uri.source = src;\n            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n            uri.ipv6uri = true;\n        }\n\n        uri.pathNames = pathNames(uri, uri['path']);\n        uri.queryKey = queryKey(uri, uri['query']);\n\n        return uri;\n    };\n\n    function pathNames(obj, path) {\n        var regx = /\\/{2,9}/g,\n            names = path.replace(regx, \"/\").split(\"/\");\n\n        if (path.substr(0, 1) == '/' || path.length === 0) {\n            names.splice(0, 1);\n        }\n        if (path.substr(path.length - 1, 1) == '/') {\n            names.splice(names.length - 1, 1);\n        }\n\n        return names;\n    }\n\n    function queryKey(uri, query) {\n        var data = {};\n\n        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n            if ($1) {\n                data[$1] = $2;\n            }\n        });\n\n        return data;\n    }",
                    "originalLength": 1823,
                    "removedExports": [],
                    "renderedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedLength": 1820
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\url.js": {
                    "code": "    /**\n     * URL parser.\n     *\n     * @param uri - url\n     * @param path - the request path of the connection\n     * @param loc - An object meant to mimic window.location.\n     *        Defaults to window.location.\n     * @public\n     */\n    function url(uri, path = \"\", loc) {\n        let obj = uri;\n        // default to window.location\n        loc = loc || (typeof location !== \"undefined\" && location);\n        if (null == uri)\n            uri = loc.protocol + \"//\" + loc.host;\n        // relative path support\n        if (typeof uri === \"string\") {\n            if (\"/\" === uri.charAt(0)) {\n                if (\"/\" === uri.charAt(1)) {\n                    uri = loc.protocol + uri;\n                }\n                else {\n                    uri = loc.host + uri;\n                }\n            }\n            if (!/^(https?|wss?):\\/\\//.test(uri)) {\n                if (\"undefined\" !== typeof loc) {\n                    uri = loc.protocol + \"//\" + uri;\n                }\n                else {\n                    uri = \"https://\" + uri;\n                }\n            }\n            // parse\n            obj = parseuri(uri);\n        }\n        // make sure we treat `localhost:80` and `localhost` equally\n        if (!obj.port) {\n            if (/^(http|ws)$/.test(obj.protocol)) {\n                obj.port = \"80\";\n            }\n            else if (/^(http|ws)s$/.test(obj.protocol)) {\n                obj.port = \"443\";\n            }\n        }\n        obj.path = obj.path || \"/\";\n        const ipv6 = obj.host.indexOf(\":\") !== -1;\n        const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n        // define unique id\n        obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n        // define href\n        obj.href =\n            obj.protocol +\n                \"://\" +\n                host +\n                (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n        return obj;\n    }",
                    "originalLength": 1716,
                    "removedExports": [],
                    "renderedExports": [
                        "url"
                    ],
                    "renderedLength": 1675
                },
                "\u0000C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\has-cors\\index.js?commonjs-module": {
                    "code": "    var hasCors = {exports: {}};",
                    "originalLength": 57,
                    "removedExports": [],
                    "renderedExports": [
                        "__module"
                    ],
                    "renderedLength": 28
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\has-cors\\index.js": {
                    "code": "    /**\n     * Module exports.\n     *\n     * Logic borrowed from Modernizr:\n     *\n     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n     */\n\n    try {\n      hasCors.exports = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n    } catch (err) {\n      // if XMLHttp support is disabled in IE then it will throw\n      // when trying to create\n      hasCors.exports = false;\n    }\n\n    var hasCORS = hasCors.exports;",
                    "originalLength": 396,
                    "removedExports": [],
                    "renderedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedLength": 428
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\globalThis.browser.js": {
                    "code": "    var globalThis$1 = (() => {\n        if (typeof self !== \"undefined\") {\n            return self;\n        }\n        else if (typeof window !== \"undefined\") {\n            return window;\n        }\n        else {\n            return Function(\"return this\")();\n        }\n    })();",
                    "originalLength": 230,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 233
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\xmlhttprequest.browser.js": {
                    "code": "    // browser shim for xmlhttprequest module\n    function XMLHttpRequest$1 (opts) {\n        const xdomain = opts.xdomain;\n        // XMLHttpRequest can be disabled on IE\n        try {\n            if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n                return new XMLHttpRequest();\n            }\n        }\n        catch (e) { }\n        if (!xdomain) {\n            try {\n                return new globalThis$1[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n            }\n            catch (e) { }\n        }\n    }",
                    "originalLength": 560,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 488
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\util.js": {
                    "code": "    function pick(obj, ...attr) {\n        return attr.reduce((acc, k) => {\n            if (obj.hasOwnProperty(k)) {\n                acc[k] = obj[k];\n            }\n            return acc;\n        }, {});\n    }\n    // Keep a reference to the real timeout functions so they can be used when overridden\n    const NATIVE_SET_TIMEOUT = setTimeout;\n    const NATIVE_CLEAR_TIMEOUT = clearTimeout;\n    function installTimerFunctions(obj, opts) {\n        if (opts.useNativeTimers) {\n            obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis$1);\n            obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis$1);\n        }\n        else {\n            obj.setTimeoutFn = setTimeout.bind(globalThis$1);\n            obj.clearTimeoutFn = clearTimeout.bind(globalThis$1);\n        }\n    }",
                    "originalLength": 750,
                    "removedExports": [],
                    "renderedExports": [
                        "pick",
                        "installTimerFunctions"
                    ],
                    "renderedLength": 701
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\@socket.io\\component-emitter\\index.js": {
                    "code": "    /**\n     * Expose `Emitter`.\n     */\n\n    var Emitter_1 = Emitter;\n\n    /**\n     * Initialize a new `Emitter`.\n     *\n     * @api public\n     */\n\n    function Emitter(obj) {\n      if (obj) return mixin(obj);\n    }\n\n    /**\n     * Mixin the emitter properties.\n     *\n     * @param {Object} obj\n     * @return {Object}\n     * @api private\n     */\n\n    function mixin(obj) {\n      for (var key in Emitter.prototype) {\n        obj[key] = Emitter.prototype[key];\n      }\n      return obj;\n    }\n\n    /**\n     * Listen on the given `event` with `fn`.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.on =\n    Emitter.prototype.addEventListener = function(event, fn){\n      this._callbacks = this._callbacks || {};\n      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n        .push(fn);\n      return this;\n    };\n\n    /**\n     * Adds an `event` listener that will be invoked a single\n     * time then automatically removed.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.once = function(event, fn){\n      function on() {\n        this.off(event, on);\n        fn.apply(this, arguments);\n      }\n\n      on.fn = fn;\n      this.on(event, on);\n      return this;\n    };\n\n    /**\n     * Remove the given callback for `event` or all\n     * registered callbacks.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.off =\n    Emitter.prototype.removeListener =\n    Emitter.prototype.removeAllListeners =\n    Emitter.prototype.removeEventListener = function(event, fn){\n      this._callbacks = this._callbacks || {};\n\n      // all\n      if (0 == arguments.length) {\n        this._callbacks = {};\n        return this;\n      }\n\n      // specific event\n      var callbacks = this._callbacks['$' + event];\n      if (!callbacks) return this;\n\n      // remove all handlers\n      if (1 == arguments.length) {\n        delete this._callbacks['$' + event];\n        return this;\n      }\n\n      // remove specific handler\n      var cb;\n      for (var i = 0; i < callbacks.length; i++) {\n        cb = callbacks[i];\n        if (cb === fn || cb.fn === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n\n      // Remove event specific arrays for event types that no\n      // one is subscribed for to avoid memory leak.\n      if (callbacks.length === 0) {\n        delete this._callbacks['$' + event];\n      }\n\n      return this;\n    };\n\n    /**\n     * Emit `event` with the given args.\n     *\n     * @param {String} event\n     * @param {Mixed} ...\n     * @return {Emitter}\n     */\n\n    Emitter.prototype.emit = function(event){\n      this._callbacks = this._callbacks || {};\n\n      var args = new Array(arguments.length - 1)\n        , callbacks = this._callbacks['$' + event];\n\n      for (var i = 1; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      if (callbacks) {\n        callbacks = callbacks.slice(0);\n        for (var i = 0, len = callbacks.length; i < len; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n\n      return this;\n    };\n\n    // alias used for reserved events (protected method)\n    Emitter.prototype.emitReserved = Emitter.prototype.emit;\n\n    /**\n     * Return array of callbacks for `event`.\n     *\n     * @param {String} event\n     * @return {Array}\n     * @api public\n     */\n\n    Emitter.prototype.listeners = function(event){\n      this._callbacks = this._callbacks || {};\n      return this._callbacks['$' + event] || [];\n    };\n\n    /**\n     * Check if this emitter has `event` handlers.\n     *\n     * @param {String} event\n     * @return {Boolean}\n     * @api public\n     */\n\n    Emitter.prototype.hasListeners = function(event){\n      return !! this.listeners(event).length;\n    };",
                    "originalLength": 3363,
                    "removedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedExports": [
                        "Emitter"
                    ],
                    "renderedLength": 3359
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\commons.js": {
                    "code": "    const PACKET_TYPES = Object.create(null); // no Map = no polyfill\n    PACKET_TYPES[\"open\"] = \"0\";\n    PACKET_TYPES[\"close\"] = \"1\";\n    PACKET_TYPES[\"ping\"] = \"2\";\n    PACKET_TYPES[\"pong\"] = \"3\";\n    PACKET_TYPES[\"message\"] = \"4\";\n    PACKET_TYPES[\"upgrade\"] = \"5\";\n    PACKET_TYPES[\"noop\"] = \"6\";\n    const PACKET_TYPES_REVERSE = Object.create(null);\n    Object.keys(PACKET_TYPES).forEach(key => {\n        PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n    });\n    const ERROR_PACKET = { type: \"error\", data: \"parser error\" };",
                    "originalLength": 540,
                    "removedExports": [],
                    "renderedExports": [
                        "PACKET_TYPES",
                        "PACKET_TYPES_REVERSE",
                        "ERROR_PACKET"
                    ],
                    "renderedLength": 478
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\encodePacket.browser.js": {
                    "code": "    const withNativeBlob$1 = typeof Blob === \"function\" ||\n        (typeof Blob !== \"undefined\" &&\n            Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\n    const withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\n    // ArrayBuffer.isView method is not defined in IE10\n    const isView$1 = obj => {\n        return typeof ArrayBuffer.isView === \"function\"\n            ? ArrayBuffer.isView(obj)\n            : obj && obj.buffer instanceof ArrayBuffer;\n    };\n    const encodePacket = ({ type, data }, supportsBinary, callback) => {\n        if (withNativeBlob$1 && data instanceof Blob) {\n            if (supportsBinary) {\n                return callback(data);\n            }\n            else {\n                return encodeBlobAsBase64(data, callback);\n            }\n        }\n        else if (withNativeArrayBuffer$2 &&\n            (data instanceof ArrayBuffer || isView$1(data))) {\n            if (supportsBinary) {\n                return callback(data);\n            }\n            else {\n                return encodeBlobAsBase64(new Blob([data]), callback);\n            }\n        }\n        // plain string\n        return callback(PACKET_TYPES[type] + (data || \"\"));\n    };\n    const encodeBlobAsBase64 = (data, callback) => {\n        const fileReader = new FileReader();\n        fileReader.onload = function () {\n            const content = fileReader.result.split(\",\")[1];\n            callback(\"b\" + content);\n        };\n        return fileReader.readAsDataURL(data);\n    };",
                    "originalLength": 1421,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 1358
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\base64-arraybuffer\\dist\\base64-arraybuffer.es5.js": {
                    "code": "    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$1 = 0; i$1 < chars.length; i$1++) {\n        lookup$1[chars.charCodeAt(i$1)] = i$1;\n    }\n    var decode$1 = function (base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === '=') {\n            bufferLength--;\n            if (base64[base64.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = lookup$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n        return arraybuffer;\n    };",
                    "originalLength": 1995,
                    "removedExports": [
                        "encode"
                    ],
                    "renderedExports": [
                        "decode"
                    ],
                    "renderedLength": 1334
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\decodePacket.browser.js": {
                    "code": "    const withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\n    const decodePacket = (encodedPacket, binaryType) => {\n        if (typeof encodedPacket !== \"string\") {\n            return {\n                type: \"message\",\n                data: mapBinary(encodedPacket, binaryType)\n            };\n        }\n        const type = encodedPacket.charAt(0);\n        if (type === \"b\") {\n            return {\n                type: \"message\",\n                data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n            };\n        }\n        const packetType = PACKET_TYPES_REVERSE[type];\n        if (!packetType) {\n            return ERROR_PACKET;\n        }\n        return encodedPacket.length > 1\n            ? {\n                type: PACKET_TYPES_REVERSE[type],\n                data: encodedPacket.substring(1)\n            }\n            : {\n                type: PACKET_TYPES_REVERSE[type]\n            };\n    };\n    const decodeBase64Packet = (data, binaryType) => {\n        if (withNativeArrayBuffer$1) {\n            const decoded = decode$1(data);\n            return mapBinary(decoded, binaryType);\n        }\n        else {\n            return { base64: true, data }; // fallback for old browsers\n        }\n    };\n    const mapBinary = (data, binaryType) => {\n        switch (binaryType) {\n            case \"blob\":\n                return data instanceof ArrayBuffer ? new Blob([data]) : data;\n            case \"arraybuffer\":\n            default:\n                return data; // assuming the data is already an ArrayBuffer\n        }\n    };",
                    "originalLength": 1510,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 1374
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\index.js": {
                    "code": "    const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n    const encodePayload = (packets, callback) => {\n        // some packets may be added to the array while encoding, so the initial length must be saved\n        const length = packets.length;\n        const encodedPackets = new Array(length);\n        let count = 0;\n        packets.forEach((packet, i) => {\n            // force base64 encoding for binary packets\n            encodePacket(packet, false, encodedPacket => {\n                encodedPackets[i] = encodedPacket;\n                if (++count === length) {\n                    callback(encodedPackets.join(SEPARATOR));\n                }\n            });\n        });\n    };\n    const decodePayload = (encodedPayload, binaryType) => {\n        const encodedPackets = encodedPayload.split(SEPARATOR);\n        const packets = [];\n        for (let i = 0; i < encodedPackets.length; i++) {\n            const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n            packets.push(decodedPacket);\n            if (decodedPacket.type === \"error\") {\n                break;\n            }\n        }\n        return packets;\n    };\n    const protocol$1 = 4;",
                    "originalLength": 1278,
                    "removedExports": [],
                    "renderedExports": [
                        "protocol",
                        "encodePacket",
                        "encodePayload",
                        "decodePacket",
                        "decodePayload"
                    ],
                    "renderedLength": 1111
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transport.js": {
                    "code": "    class Transport extends Emitter_1 {\n        /**\n         * Transport abstract constructor.\n         *\n         * @param {Object} options.\n         * @api private\n         */\n        constructor(opts) {\n            super();\n            this.writable = false;\n            installTimerFunctions(this, opts);\n            this.opts = opts;\n            this.query = opts.query;\n            this.readyState = \"\";\n            this.socket = opts.socket;\n        }\n        /**\n         * Emits an error.\n         *\n         * @param {String} str\n         * @return {Transport} for chaining\n         * @api protected\n         */\n        onError(msg, desc) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            super.emit(\"error\", err);\n            return this;\n        }\n        /**\n         * Opens the transport.\n         *\n         * @api public\n         */\n        open() {\n            if (\"closed\" === this.readyState || \"\" === this.readyState) {\n                this.readyState = \"opening\";\n                this.doOpen();\n            }\n            return this;\n        }\n        /**\n         * Closes the transport.\n         *\n         * @api public\n         */\n        close() {\n            if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.doClose();\n                this.onClose();\n            }\n            return this;\n        }\n        /**\n         * Sends multiple packets.\n         *\n         * @param {Array} packets\n         * @api public\n         */\n        send(packets) {\n            if (\"open\" === this.readyState) {\n                this.write(packets);\n            }\n        }\n        /**\n         * Called upon open\n         *\n         * @api protected\n         */\n        onOpen() {\n            this.readyState = \"open\";\n            this.writable = true;\n            super.emit(\"open\");\n        }\n        /**\n         * Called with data.\n         *\n         * @param {String} data\n         * @api protected\n         */\n        onData(data) {\n            const packet = decodePacket(data, this.socket.binaryType);\n            this.onPacket(packet);\n        }\n        /**\n         * Called with a decoded packet.\n         *\n         * @api protected\n         */\n        onPacket(packet) {\n            super.emit(\"packet\", packet);\n        }\n        /**\n         * Called upon close.\n         *\n         * @api protected\n         */\n        onClose() {\n            this.readyState = \"closed\";\n            super.emit(\"close\");\n        }\n    }",
                    "originalLength": 2492,
                    "removedExports": [],
                    "renderedExports": [
                        "Transport"
                    ],
                    "renderedLength": 2201
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\yeast\\index.js": {
                    "code": "    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n      , length = 64\n      , map = {}\n      , seed = 0\n      , i = 0\n      , prev;\n\n    /**\n     * Return a string representing the specified number.\n     *\n     * @param {Number} num The number to convert.\n     * @returns {String} The string representation of the number.\n     * @api public\n     */\n    function encode(num) {\n      var encoded = '';\n\n      do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n      } while (num > 0);\n\n      return encoded;\n    }\n\n    /**\n     * Return the integer value specified by the given string.\n     *\n     * @param {String} str The string to convert.\n     * @returns {Number} The integer value represented by the string.\n     * @api public\n     */\n    function decode(str) {\n      var decoded = 0;\n\n      for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n      }\n\n      return decoded;\n    }\n\n    /**\n     * Yeast: A tiny growing id generator.\n     *\n     * @returns {String} A unique id.\n     * @api public\n     */\n    function yeast() {\n      var now = encode(+new Date());\n\n      if (now !== prev) return seed = 0, prev = now;\n      return now +'.'+ encode(seed++);\n    }\n\n    //\n    // Map each character to its index.\n    //\n    for (; i < length; i++) map[alphabet[i]] = i;\n\n    //\n    // Expose the `yeast`, `encode` and `decode` functions.\n    //\n    yeast.encode = encode;\n    yeast.decode = decode;\n    var yeast_1 = yeast;",
                    "originalLength": 1352,
                    "removedExports": [],
                    "renderedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedLength": 1333
                },
                "\u0000C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseqs\\index.js?commonjs-exports": {
                    "code": "    var parseqs = {};",
                    "originalLength": 47,
                    "removedExports": [],
                    "renderedExports": [
                        "__exports"
                    ],
                    "renderedLength": 17
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseqs\\index.js": {
                    "code": "    /**\n     * Compiles a querystring\n     * Returns string representation of the object\n     *\n     * @param {Object}\n     * @api private\n     */\n\n    parseqs.encode = function (obj) {\n      var str = '';\n\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          if (str.length) str += '&';\n          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n      }\n\n      return str;\n    };\n\n    /**\n     * Parses a simple querystring into an object\n     *\n     * @param {String} qs\n     * @api private\n     */\n\n    parseqs.decode = function(qs){\n      var qry = {};\n      var pairs = qs.split('&');\n      for (var i = 0, l = pairs.length; i < l; i++) {\n        var pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n      }\n      return qry;\n    };",
                    "originalLength": 708,
                    "removedExports": [
                        "encode",
                        "decode"
                    ],
                    "renderedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedLength": 707
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js": {
                    "code": "    class Polling extends Transport {\n        constructor() {\n            super(...arguments);\n            this.polling = false;\n        }\n        /**\n         * Transport name.\n         */\n        get name() {\n            return \"polling\";\n        }\n        /**\n         * Opens the socket (triggers polling). We write a PING message to determine\n         * when the transport is open.\n         *\n         * @api private\n         */\n        doOpen() {\n            this.poll();\n        }\n        /**\n         * Pauses polling.\n         *\n         * @param {Function} callback upon buffers are flushed and transport is paused\n         * @api private\n         */\n        pause(onPause) {\n            this.readyState = \"pausing\";\n            const pause = () => {\n                this.readyState = \"paused\";\n                onPause();\n            };\n            if (this.polling || !this.writable) {\n                let total = 0;\n                if (this.polling) {\n                    total++;\n                    this.once(\"pollComplete\", function () {\n                        --total || pause();\n                    });\n                }\n                if (!this.writable) {\n                    total++;\n                    this.once(\"drain\", function () {\n                        --total || pause();\n                    });\n                }\n            }\n            else {\n                pause();\n            }\n        }\n        /**\n         * Starts polling cycle.\n         *\n         * @api public\n         */\n        poll() {\n            this.polling = true;\n            this.doPoll();\n            this.emit(\"poll\");\n        }\n        /**\n         * Overloads onData to detect payloads.\n         *\n         * @api private\n         */\n        onData(data) {\n            const callback = packet => {\n                // if its the first message we consider the transport open\n                if (\"opening\" === this.readyState && packet.type === \"open\") {\n                    this.onOpen();\n                }\n                // if its a close packet, we close the ongoing requests\n                if (\"close\" === packet.type) {\n                    this.onClose();\n                    return false;\n                }\n                // otherwise bypass onData and handle the message\n                this.onPacket(packet);\n            };\n            // decode payload\n            decodePayload(data, this.socket.binaryType).forEach(callback);\n            // if an event did not trigger closing\n            if (\"closed\" !== this.readyState) {\n                // if we got data we're not polling\n                this.polling = false;\n                this.emit(\"pollComplete\");\n                if (\"open\" === this.readyState) {\n                    this.poll();\n                }\n            }\n        }\n        /**\n         * For polling, send a close packet.\n         *\n         * @api private\n         */\n        doClose() {\n            const close = () => {\n                this.write([{ type: \"close\" }]);\n            };\n            if (\"open\" === this.readyState) {\n                close();\n            }\n            else {\n                // in case we're trying to close while\n                // handshaking is in progress (GH-164)\n                this.once(\"open\", close);\n            }\n        }\n        /**\n         * Writes a packets payload.\n         *\n         * @param {Array} data packets\n         * @param {Function} drain callback\n         * @api private\n         */\n        write(packets) {\n            this.writable = false;\n            encodePayload(packets, data => {\n                this.doWrite(data, () => {\n                    this.writable = true;\n                    this.emit(\"drain\");\n                });\n            });\n        }\n        /**\n         * Generates uri for connection.\n         *\n         * @api private\n         */\n        uri() {\n            let query = this.query || {};\n            const schema = this.opts.secure ? \"https\" : \"http\";\n            let port = \"\";\n            // cache busting is forced\n            if (false !== this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast_1();\n            }\n            if (!this.supportsBinary && !query.sid) {\n                query.b64 = 1;\n            }\n            // avoid port if default for schema\n            if (this.opts.port &&\n                ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                    (\"http\" === schema && Number(this.opts.port) !== 80))) {\n                port = \":\" + this.opts.port;\n            }\n            const encodedQuery = parseqs.encode(query);\n            const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n            return (schema +\n                \"://\" +\n                (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n                port +\n                this.opts.path +\n                (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n        }\n    }",
                    "originalLength": 4537,
                    "removedExports": [],
                    "renderedExports": [
                        "Polling"
                    ],
                    "renderedLength": 4330
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\polling-xhr.js": {
                    "code": "    /* global attachEvent */\n    /**\n     * Empty function\n     */\n    function empty() { }\n    const hasXHR2 = (function () {\n        const xhr = new XMLHttpRequest$1({\n            xdomain: false\n        });\n        return null != xhr.responseType;\n    })();\n    class XHR extends Polling {\n        /**\n         * XHR Polling constructor.\n         *\n         * @param {Object} opts\n         * @api public\n         */\n        constructor(opts) {\n            super(opts);\n            if (typeof location !== \"undefined\") {\n                const isSSL = \"https:\" === location.protocol;\n                let port = location.port;\n                // some user agents have empty `location.port`\n                if (!port) {\n                    port = isSSL ? \"443\" : \"80\";\n                }\n                this.xd =\n                    (typeof location !== \"undefined\" &&\n                        opts.hostname !== location.hostname) ||\n                        port !== opts.port;\n                this.xs = opts.secure !== isSSL;\n            }\n            /**\n             * XHR supports binary\n             */\n            const forceBase64 = opts && opts.forceBase64;\n            this.supportsBinary = hasXHR2 && !forceBase64;\n        }\n        /**\n         * Creates a request.\n         *\n         * @param {String} method\n         * @api private\n         */\n        request(opts = {}) {\n            Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n            return new Request(this.uri(), opts);\n        }\n        /**\n         * Sends data.\n         *\n         * @param {String} data to send.\n         * @param {Function} called upon flush.\n         * @api private\n         */\n        doWrite(data, fn) {\n            const req = this.request({\n                method: \"POST\",\n                data: data\n            });\n            req.on(\"success\", fn);\n            req.on(\"error\", err => {\n                this.onError(\"xhr post error\", err);\n            });\n        }\n        /**\n         * Starts a poll cycle.\n         *\n         * @api private\n         */\n        doPoll() {\n            const req = this.request();\n            req.on(\"data\", this.onData.bind(this));\n            req.on(\"error\", err => {\n                this.onError(\"xhr poll error\", err);\n            });\n            this.pollXhr = req;\n        }\n    }\n    class Request extends Emitter_1 {\n        /**\n         * Request constructor\n         *\n         * @param {Object} options\n         * @api public\n         */\n        constructor(uri, opts) {\n            super();\n            installTimerFunctions(this, opts);\n            this.opts = opts;\n            this.method = opts.method || \"GET\";\n            this.uri = uri;\n            this.async = false !== opts.async;\n            this.data = undefined !== opts.data ? opts.data : null;\n            this.create();\n        }\n        /**\n         * Creates the XHR object and sends the request.\n         *\n         * @api private\n         */\n        create() {\n            const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n            opts.xdomain = !!this.opts.xd;\n            opts.xscheme = !!this.opts.xs;\n            const xhr = (this.xhr = new XMLHttpRequest$1(opts));\n            try {\n                xhr.open(this.method, this.uri, this.async);\n                try {\n                    if (this.opts.extraHeaders) {\n                        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                        for (let i in this.opts.extraHeaders) {\n                            if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                            }\n                        }\n                    }\n                }\n                catch (e) { }\n                if (\"POST\" === this.method) {\n                    try {\n                        xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                    }\n                    catch (e) { }\n                }\n                try {\n                    xhr.setRequestHeader(\"Accept\", \"*/*\");\n                }\n                catch (e) { }\n                // ie6 check\n                if (\"withCredentials\" in xhr) {\n                    xhr.withCredentials = this.opts.withCredentials;\n                }\n                if (this.opts.requestTimeout) {\n                    xhr.timeout = this.opts.requestTimeout;\n                }\n                xhr.onreadystatechange = () => {\n                    if (4 !== xhr.readyState)\n                        return;\n                    if (200 === xhr.status || 1223 === xhr.status) {\n                        this.onLoad();\n                    }\n                    else {\n                        // make sure the `error` event handler that's user-set\n                        // does not throw in the same tick and gets caught here\n                        this.setTimeoutFn(() => {\n                            this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                        }, 0);\n                    }\n                };\n                xhr.send(this.data);\n            }\n            catch (e) {\n                // Need to defer since .create() is called directly from the constructor\n                // and thus the 'error' event can only be only bound *after* this exception\n                // occurs.  Therefore, also, we cannot throw here at all.\n                this.setTimeoutFn(() => {\n                    this.onError(e);\n                }, 0);\n                return;\n            }\n            if (typeof document !== \"undefined\") {\n                this.index = Request.requestsCount++;\n                Request.requests[this.index] = this;\n            }\n        }\n        /**\n         * Called upon successful response.\n         *\n         * @api private\n         */\n        onSuccess() {\n            this.emit(\"success\");\n            this.cleanup();\n        }\n        /**\n         * Called if we have data.\n         *\n         * @api private\n         */\n        onData(data) {\n            this.emit(\"data\", data);\n            this.onSuccess();\n        }\n        /**\n         * Called upon error.\n         *\n         * @api private\n         */\n        onError(err) {\n            this.emit(\"error\", err);\n            this.cleanup(true);\n        }\n        /**\n         * Cleans up house.\n         *\n         * @api private\n         */\n        cleanup(fromError) {\n            if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n                return;\n            }\n            this.xhr.onreadystatechange = empty;\n            if (fromError) {\n                try {\n                    this.xhr.abort();\n                }\n                catch (e) { }\n            }\n            if (typeof document !== \"undefined\") {\n                delete Request.requests[this.index];\n            }\n            this.xhr = null;\n        }\n        /**\n         * Called upon load.\n         *\n         * @api private\n         */\n        onLoad() {\n            const data = this.xhr.responseText;\n            if (data !== null) {\n                this.onData(data);\n            }\n        }\n        /**\n         * Aborts the request.\n         *\n         * @api public\n         */\n        abort() {\n            this.cleanup();\n        }\n    }\n    Request.requestsCount = 0;\n    Request.requests = {};\n    /**\n     * Aborts pending requests when unloading the window. This is needed to prevent\n     * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n     * emitted.\n     */\n    if (typeof document !== \"undefined\") {\n        // @ts-ignore\n        if (typeof attachEvent === \"function\") {\n            // @ts-ignore\n            attachEvent(\"onunload\", unloadHandler);\n        }\n        else if (typeof addEventListener === \"function\") {\n            const terminationEvent = \"onpagehide\" in globalThis$1 ? \"pagehide\" : \"unload\";\n            addEventListener(terminationEvent, unloadHandler, false);\n        }\n    }\n    function unloadHandler() {\n        for (let i in Request.requests) {\n            if (Request.requests.hasOwnProperty(i)) {\n                Request.requests[i].abort();\n            }\n        }\n    }",
                    "originalLength": 7505,
                    "removedExports": [],
                    "renderedExports": [
                        "XHR",
                        "Request"
                    ],
                    "renderedLength": 7251
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\websocket-constructor.browser.js": {
                    "code": "    const nextTick = (() => {\n        const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n        if (isPromiseAvailable) {\n            return cb => Promise.resolve().then(cb);\n        }\n        else {\n            return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n        }\n    })();\n    const WebSocket = globalThis$1.WebSocket || globalThis$1.MozWebSocket;\n    const usingBrowserWebSocket = true;\n    const defaultBinaryType = \"arraybuffer\";",
                    "originalLength": 510,
                    "removedExports": [],
                    "renderedExports": [
                        "nextTick",
                        "WebSocket",
                        "usingBrowserWebSocket",
                        "defaultBinaryType"
                    ],
                    "renderedLength": 442
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\websocket.js": {
                    "code": "    // detect ReactNative environment\n    const isReactNative = typeof navigator !== \"undefined\" &&\n        typeof navigator.product === \"string\" &&\n        navigator.product.toLowerCase() === \"reactnative\";\n    class WS extends Transport {\n        /**\n         * WebSocket transport constructor.\n         *\n         * @api {Object} connection options\n         * @api public\n         */\n        constructor(opts) {\n            super(opts);\n            this.supportsBinary = !opts.forceBase64;\n        }\n        /**\n         * Transport name.\n         *\n         * @api public\n         */\n        get name() {\n            return \"websocket\";\n        }\n        /**\n         * Opens socket.\n         *\n         * @api private\n         */\n        doOpen() {\n            if (!this.check()) {\n                // let probe timeout\n                return;\n            }\n            const uri = this.uri();\n            const protocols = this.opts.protocols;\n            // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n            const opts = isReactNative\n                ? {}\n                : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n            if (this.opts.extraHeaders) {\n                opts.headers = this.opts.extraHeaders;\n            }\n            try {\n                this.ws =\n                    usingBrowserWebSocket && !isReactNative\n                        ? protocols\n                            ? new WebSocket(uri, protocols)\n                            : new WebSocket(uri)\n                        : new WebSocket(uri, protocols, opts);\n            }\n            catch (err) {\n                return this.emit(\"error\", err);\n            }\n            this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n            this.addEventListeners();\n        }\n        /**\n         * Adds event listeners to the socket\n         *\n         * @api private\n         */\n        addEventListeners() {\n            this.ws.onopen = () => {\n                if (this.opts.autoUnref) {\n                    this.ws._socket.unref();\n                }\n                this.onOpen();\n            };\n            this.ws.onclose = this.onClose.bind(this);\n            this.ws.onmessage = ev => this.onData(ev.data);\n            this.ws.onerror = e => this.onError(\"websocket error\", e);\n        }\n        /**\n         * Writes data to socket.\n         *\n         * @param {Array} array of packets.\n         * @api private\n         */\n        write(packets) {\n            this.writable = false;\n            // encodePacket efficient as it uses WS framing\n            // no need for encodePayload\n            for (let i = 0; i < packets.length; i++) {\n                const packet = packets[i];\n                const lastPacket = i === packets.length - 1;\n                encodePacket(packet, this.supportsBinary, data => {\n                    // always create a new object (GH-437)\n                    const opts = {};\n                    // Sometimes the websocket has already been closed but the browser didn't\n                    // have a chance of informing us about it yet, in that case send will\n                    // throw an error\n                    try {\n                        if (usingBrowserWebSocket) {\n                            // TypeError is thrown when passing the second argument on Safari\n                            this.ws.send(data);\n                        }\n                    }\n                    catch (e) {\n                    }\n                    if (lastPacket) {\n                        // fake drain\n                        // defer to next tick to allow Socket to clear writeBuffer\n                        nextTick(() => {\n                            this.writable = true;\n                            this.emit(\"drain\");\n                        }, this.setTimeoutFn);\n                    }\n                });\n            }\n        }\n        /**\n         * Closes socket.\n         *\n         * @api private\n         */\n        doClose() {\n            if (typeof this.ws !== \"undefined\") {\n                this.ws.close();\n                this.ws = null;\n            }\n        }\n        /**\n         * Generates uri for connection.\n         *\n         * @api private\n         */\n        uri() {\n            let query = this.query || {};\n            const schema = this.opts.secure ? \"wss\" : \"ws\";\n            let port = \"\";\n            // avoid port if default for schema\n            if (this.opts.port &&\n                ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                    (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n                port = \":\" + this.opts.port;\n            }\n            // append timestamp to URI\n            if (this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast_1();\n            }\n            // communicate binary support capabilities\n            if (!this.supportsBinary) {\n                query.b64 = 1;\n            }\n            const encodedQuery = parseqs.encode(query);\n            const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n            return (schema +\n                \"://\" +\n                (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n                port +\n                this.opts.path +\n                (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n        }\n        /**\n         * Feature detection for WebSocket.\n         *\n         * @return {Boolean} whether this transport is available.\n         * @api public\n         */\n        check() {\n            return (!!WebSocket &&\n                !(\"__initialize\" in WebSocket && this.name === WS.prototype.name));\n        }\n    }",
                    "originalLength": 6157,
                    "removedExports": [],
                    "renderedExports": [
                        "WS"
                    ],
                    "renderedLength": 5233
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\index.js": {
                    "code": "    const transports = {\n        websocket: WS,\n        polling: XHR\n    };",
                    "originalLength": 144,
                    "removedExports": [],
                    "renderedExports": [
                        "transports"
                    ],
                    "renderedLength": 59
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\socket.js": {
                    "code": "    class Socket$1 extends Emitter_1 {\n        /**\n         * Socket constructor.\n         *\n         * @param {String|Object} uri or options\n         * @param {Object} opts - options\n         * @api public\n         */\n        constructor(uri, opts = {}) {\n            super();\n            if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = null;\n            }\n            if (uri) {\n                uri = parseuri(uri);\n                opts.hostname = uri.host;\n                opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n                opts.port = uri.port;\n                if (uri.query)\n                    opts.query = uri.query;\n            }\n            else if (opts.host) {\n                opts.hostname = parseuri(opts.host).host;\n            }\n            installTimerFunctions(this, opts);\n            this.secure =\n                null != opts.secure\n                    ? opts.secure\n                    : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n            if (opts.hostname && !opts.port) {\n                // if no port is specified manually, use the protocol default\n                opts.port = this.secure ? \"443\" : \"80\";\n            }\n            this.hostname =\n                opts.hostname ||\n                    (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n            this.port =\n                opts.port ||\n                    (typeof location !== \"undefined\" && location.port\n                        ? location.port\n                        : this.secure\n                            ? \"443\"\n                            : \"80\");\n            this.transports = opts.transports || [\"polling\", \"websocket\"];\n            this.readyState = \"\";\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n            this.opts = Object.assign({\n                path: \"/engine.io\",\n                agent: false,\n                withCredentials: false,\n                upgrade: true,\n                timestampParam: \"t\",\n                rememberUpgrade: false,\n                rejectUnauthorized: true,\n                perMessageDeflate: {\n                    threshold: 1024\n                },\n                transportOptions: {},\n                closeOnBeforeunload: true\n            }, opts);\n            this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n            if (typeof this.opts.query === \"string\") {\n                this.opts.query = parseqs.decode(this.opts.query);\n            }\n            // set on handshake\n            this.id = null;\n            this.upgrades = null;\n            this.pingInterval = null;\n            this.pingTimeout = null;\n            // set on heartbeat\n            this.pingTimeoutTimer = null;\n            if (typeof addEventListener === \"function\") {\n                if (this.opts.closeOnBeforeunload) {\n                    // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                    // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                    // closed/reloaded)\n                    addEventListener(\"beforeunload\", () => {\n                        if (this.transport) {\n                            // silently close the transport\n                            this.transport.removeAllListeners();\n                            this.transport.close();\n                        }\n                    }, false);\n                }\n                if (this.hostname !== \"localhost\") {\n                    this.offlineEventListener = () => {\n                        this.onClose(\"transport close\");\n                    };\n                    addEventListener(\"offline\", this.offlineEventListener, false);\n                }\n            }\n            this.open();\n        }\n        /**\n         * Creates transport of the given type.\n         *\n         * @param {String} transport name\n         * @return {Transport}\n         * @api private\n         */\n        createTransport(name) {\n            const query = clone(this.opts.query);\n            // append engine.io protocol identifier\n            query.EIO = protocol$1;\n            // transport name\n            query.transport = name;\n            // session id if we already have one\n            if (this.id)\n                query.sid = this.id;\n            const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n                query,\n                socket: this,\n                hostname: this.hostname,\n                secure: this.secure,\n                port: this.port\n            });\n            return new transports[name](opts);\n        }\n        /**\n         * Initializes transport to use and starts probe.\n         *\n         * @api private\n         */\n        open() {\n            let transport;\n            if (this.opts.rememberUpgrade &&\n                Socket$1.priorWebsocketSuccess &&\n                this.transports.indexOf(\"websocket\") !== -1) {\n                transport = \"websocket\";\n            }\n            else if (0 === this.transports.length) {\n                // Emit error on next tick so it can be listened to\n                this.setTimeoutFn(() => {\n                    this.emitReserved(\"error\", \"No transports available\");\n                }, 0);\n                return;\n            }\n            else {\n                transport = this.transports[0];\n            }\n            this.readyState = \"opening\";\n            // Retry with the next transport if the transport is disabled (jsonp: false)\n            try {\n                transport = this.createTransport(transport);\n            }\n            catch (e) {\n                this.transports.shift();\n                this.open();\n                return;\n            }\n            transport.open();\n            this.setTransport(transport);\n        }\n        /**\n         * Sets the current transport. Disables the existing one (if any).\n         *\n         * @api private\n         */\n        setTransport(transport) {\n            if (this.transport) {\n                this.transport.removeAllListeners();\n            }\n            // set up transport\n            this.transport = transport;\n            // set up transport listeners\n            transport\n                .on(\"drain\", this.onDrain.bind(this))\n                .on(\"packet\", this.onPacket.bind(this))\n                .on(\"error\", this.onError.bind(this))\n                .on(\"close\", () => {\n                this.onClose(\"transport close\");\n            });\n        }\n        /**\n         * Probes a transport.\n         *\n         * @param {String} transport name\n         * @api private\n         */\n        probe(name) {\n            let transport = this.createTransport(name);\n            let failed = false;\n            Socket$1.priorWebsocketSuccess = false;\n            const onTransportOpen = () => {\n                if (failed)\n                    return;\n                transport.send([{ type: \"ping\", data: \"probe\" }]);\n                transport.once(\"packet\", msg => {\n                    if (failed)\n                        return;\n                    if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                        this.upgrading = true;\n                        this.emitReserved(\"upgrading\", transport);\n                        if (!transport)\n                            return;\n                        Socket$1.priorWebsocketSuccess = \"websocket\" === transport.name;\n                        this.transport.pause(() => {\n                            if (failed)\n                                return;\n                            if (\"closed\" === this.readyState)\n                                return;\n                            cleanup();\n                            this.setTransport(transport);\n                            transport.send([{ type: \"upgrade\" }]);\n                            this.emitReserved(\"upgrade\", transport);\n                            transport = null;\n                            this.upgrading = false;\n                            this.flush();\n                        });\n                    }\n                    else {\n                        const err = new Error(\"probe error\");\n                        // @ts-ignore\n                        err.transport = transport.name;\n                        this.emitReserved(\"upgradeError\", err);\n                    }\n                });\n            };\n            function freezeTransport() {\n                if (failed)\n                    return;\n                // Any callback called by transport should be ignored since now\n                failed = true;\n                cleanup();\n                transport.close();\n                transport = null;\n            }\n            // Handle any error that happens while probing\n            const onerror = err => {\n                const error = new Error(\"probe error: \" + err);\n                // @ts-ignore\n                error.transport = transport.name;\n                freezeTransport();\n                this.emitReserved(\"upgradeError\", error);\n            };\n            function onTransportClose() {\n                onerror(\"transport closed\");\n            }\n            // When the socket is closed while we're probing\n            function onclose() {\n                onerror(\"socket closed\");\n            }\n            // When the socket is upgraded while we're probing\n            function onupgrade(to) {\n                if (transport && to.name !== transport.name) {\n                    freezeTransport();\n                }\n            }\n            // Remove all listeners on the transport and on self\n            const cleanup = () => {\n                transport.removeListener(\"open\", onTransportOpen);\n                transport.removeListener(\"error\", onerror);\n                transport.removeListener(\"close\", onTransportClose);\n                this.off(\"close\", onclose);\n                this.off(\"upgrading\", onupgrade);\n            };\n            transport.once(\"open\", onTransportOpen);\n            transport.once(\"error\", onerror);\n            transport.once(\"close\", onTransportClose);\n            this.once(\"close\", onclose);\n            this.once(\"upgrading\", onupgrade);\n            transport.open();\n        }\n        /**\n         * Called when connection is deemed open.\n         *\n         * @api private\n         */\n        onOpen() {\n            this.readyState = \"open\";\n            Socket$1.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n            this.emitReserved(\"open\");\n            this.flush();\n            // we check for `readyState` in case an `open`\n            // listener already closed the socket\n            if (\"open\" === this.readyState &&\n                this.opts.upgrade &&\n                this.transport.pause) {\n                let i = 0;\n                const l = this.upgrades.length;\n                for (; i < l; i++) {\n                    this.probe(this.upgrades[i]);\n                }\n            }\n        }\n        /**\n         * Handles a packet.\n         *\n         * @api private\n         */\n        onPacket(packet) {\n            if (\"opening\" === this.readyState ||\n                \"open\" === this.readyState ||\n                \"closing\" === this.readyState) {\n                this.emitReserved(\"packet\", packet);\n                // Socket is live - any packet counts\n                this.emitReserved(\"heartbeat\");\n                switch (packet.type) {\n                    case \"open\":\n                        this.onHandshake(JSON.parse(packet.data));\n                        break;\n                    case \"ping\":\n                        this.resetPingTimeout();\n                        this.sendPacket(\"pong\");\n                        this.emitReserved(\"ping\");\n                        this.emitReserved(\"pong\");\n                        break;\n                    case \"error\":\n                        const err = new Error(\"server error\");\n                        // @ts-ignore\n                        err.code = packet.data;\n                        this.onError(err);\n                        break;\n                    case \"message\":\n                        this.emitReserved(\"data\", packet.data);\n                        this.emitReserved(\"message\", packet.data);\n                        break;\n                }\n            }\n        }\n        /**\n         * Called upon handshake completion.\n         *\n         * @param {Object} data - handshake obj\n         * @api private\n         */\n        onHandshake(data) {\n            this.emitReserved(\"handshake\", data);\n            this.id = data.sid;\n            this.transport.query.sid = data.sid;\n            this.upgrades = this.filterUpgrades(data.upgrades);\n            this.pingInterval = data.pingInterval;\n            this.pingTimeout = data.pingTimeout;\n            this.onOpen();\n            // In case open handler closes socket\n            if (\"closed\" === this.readyState)\n                return;\n            this.resetPingTimeout();\n        }\n        /**\n         * Sets and resets ping timeout timer based on server pings.\n         *\n         * @api private\n         */\n        resetPingTimeout() {\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            this.pingTimeoutTimer = this.setTimeoutFn(() => {\n                this.onClose(\"ping timeout\");\n            }, this.pingInterval + this.pingTimeout);\n            if (this.opts.autoUnref) {\n                this.pingTimeoutTimer.unref();\n            }\n        }\n        /**\n         * Called on `drain` event\n         *\n         * @api private\n         */\n        onDrain() {\n            this.writeBuffer.splice(0, this.prevBufferLen);\n            // setting prevBufferLen = 0 is very important\n            // for example, when upgrading, upgrade packet is sent over,\n            // and a nonzero prevBufferLen could cause problems on `drain`\n            this.prevBufferLen = 0;\n            if (0 === this.writeBuffer.length) {\n                this.emitReserved(\"drain\");\n            }\n            else {\n                this.flush();\n            }\n        }\n        /**\n         * Flush write buffers.\n         *\n         * @api private\n         */\n        flush() {\n            if (\"closed\" !== this.readyState &&\n                this.transport.writable &&\n                !this.upgrading &&\n                this.writeBuffer.length) {\n                this.transport.send(this.writeBuffer);\n                // keep track of current length of writeBuffer\n                // splice writeBuffer and callbackBuffer on `drain`\n                this.prevBufferLen = this.writeBuffer.length;\n                this.emitReserved(\"flush\");\n            }\n        }\n        /**\n         * Sends a message.\n         *\n         * @param {String} message.\n         * @param {Function} callback function.\n         * @param {Object} options.\n         * @return {Socket} for chaining.\n         * @api public\n         */\n        write(msg, options, fn) {\n            this.sendPacket(\"message\", msg, options, fn);\n            return this;\n        }\n        send(msg, options, fn) {\n            this.sendPacket(\"message\", msg, options, fn);\n            return this;\n        }\n        /**\n         * Sends a packet.\n         *\n         * @param {String} packet type.\n         * @param {String} data.\n         * @param {Object} options.\n         * @param {Function} callback function.\n         * @api private\n         */\n        sendPacket(type, data, options, fn) {\n            if (\"function\" === typeof data) {\n                fn = data;\n                data = undefined;\n            }\n            if (\"function\" === typeof options) {\n                fn = options;\n                options = null;\n            }\n            if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n                return;\n            }\n            options = options || {};\n            options.compress = false !== options.compress;\n            const packet = {\n                type: type,\n                data: data,\n                options: options\n            };\n            this.emitReserved(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            if (fn)\n                this.once(\"flush\", fn);\n            this.flush();\n        }\n        /**\n         * Closes the connection.\n         *\n         * @api public\n         */\n        close() {\n            const close = () => {\n                this.onClose(\"forced close\");\n                this.transport.close();\n            };\n            const cleanupAndClose = () => {\n                this.off(\"upgrade\", cleanupAndClose);\n                this.off(\"upgradeError\", cleanupAndClose);\n                close();\n            };\n            const waitForUpgrade = () => {\n                // wait for upgrade to finish since we can't send packets while pausing a transport\n                this.once(\"upgrade\", cleanupAndClose);\n                this.once(\"upgradeError\", cleanupAndClose);\n            };\n            if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.readyState = \"closing\";\n                if (this.writeBuffer.length) {\n                    this.once(\"drain\", () => {\n                        if (this.upgrading) {\n                            waitForUpgrade();\n                        }\n                        else {\n                            close();\n                        }\n                    });\n                }\n                else if (this.upgrading) {\n                    waitForUpgrade();\n                }\n                else {\n                    close();\n                }\n            }\n            return this;\n        }\n        /**\n         * Called upon transport error\n         *\n         * @api private\n         */\n        onError(err) {\n            Socket$1.priorWebsocketSuccess = false;\n            this.emitReserved(\"error\", err);\n            this.onClose(\"transport error\", err);\n        }\n        /**\n         * Called upon transport close.\n         *\n         * @api private\n         */\n        onClose(reason, desc) {\n            if (\"opening\" === this.readyState ||\n                \"open\" === this.readyState ||\n                \"closing\" === this.readyState) {\n                // clear timers\n                this.clearTimeoutFn(this.pingTimeoutTimer);\n                // stop event from firing again for transport\n                this.transport.removeAllListeners(\"close\");\n                // ensure transport won't stay open\n                this.transport.close();\n                // ignore further transport communication\n                this.transport.removeAllListeners();\n                if (typeof removeEventListener === \"function\") {\n                    removeEventListener(\"offline\", this.offlineEventListener, false);\n                }\n                // set ready state\n                this.readyState = \"closed\";\n                // clear session id\n                this.id = null;\n                // emit close event\n                this.emitReserved(\"close\", reason, desc);\n                // clean buffers after, so users can still\n                // grab the buffers on `close` event\n                this.writeBuffer = [];\n                this.prevBufferLen = 0;\n            }\n        }\n        /**\n         * Filters upgrades, returning only those matching client transports.\n         *\n         * @param {Array} server upgrades\n         * @api private\n         *\n         */\n        filterUpgrades(upgrades) {\n            const filteredUpgrades = [];\n            let i = 0;\n            const j = upgrades.length;\n            for (; i < j; i++) {\n                if (~this.transports.indexOf(upgrades[i]))\n                    filteredUpgrades.push(upgrades[i]);\n            }\n            return filteredUpgrades;\n        }\n    }\n    Socket$1.protocol = protocol$1;\n    function clone(obj) {\n        const o = {};\n        for (let i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                o[i] = obj[i];\n            }\n        }\n        return o;\n    }",
                    "originalLength": 18205,
                    "removedExports": [],
                    "renderedExports": [
                        "Socket"
                    ],
                    "renderedLength": 17924
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\index.js": {
                    "code": "    Socket$1.protocol;",
                    "originalLength": 245,
                    "removedExports": [
                        "protocol"
                    ],
                    "renderedExports": [
                        "Socket"
                    ],
                    "renderedLength": 18
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\is-binary.js": {
                    "code": "    const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n    const isView = (obj) => {\n        return typeof ArrayBuffer.isView === \"function\"\n            ? ArrayBuffer.isView(obj)\n            : obj.buffer instanceof ArrayBuffer;\n    };\n    const toString = Object.prototype.toString;\n    const withNativeBlob = typeof Blob === \"function\" ||\n        (typeof Blob !== \"undefined\" &&\n            toString.call(Blob) === \"[object BlobConstructor]\");\n    const withNativeFile = typeof File === \"function\" ||\n        (typeof File !== \"undefined\" &&\n            toString.call(File) === \"[object FileConstructor]\");\n    /**\n     * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n     *\n     * @private\n     */\n    function isBinary(obj) {\n        return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n            (withNativeBlob && obj instanceof Blob) ||\n            (withNativeFile && obj instanceof File));\n    }\n    function hasBinary(obj, toJSON) {\n        if (!obj || typeof obj !== \"object\") {\n            return false;\n        }\n        if (Array.isArray(obj)) {\n            for (let i = 0, l = obj.length; i < l; i++) {\n                if (hasBinary(obj[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (isBinary(obj)) {\n            return true;\n        }\n        if (obj.toJSON &&\n            typeof obj.toJSON === \"function\" &&\n            arguments.length === 1) {\n            return hasBinary(obj.toJSON(), true);\n        }\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n                return true;\n            }\n        }\n        return false;\n    }",
                    "originalLength": 1576,
                    "removedExports": [],
                    "renderedExports": [
                        "isBinary",
                        "hasBinary"
                    ],
                    "renderedLength": 1561
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\binary.js": {
                    "code": "    /**\n     * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n     *\n     * @param {Object} packet - socket.io event packet\n     * @return {Object} with deconstructed packet and list of buffers\n     * @public\n     */\n    function deconstructPacket(packet) {\n        const buffers = [];\n        const packetData = packet.data;\n        const pack = packet;\n        pack.data = _deconstructPacket(packetData, buffers);\n        pack.attachments = buffers.length; // number of binary 'attachments'\n        return { packet: pack, buffers: buffers };\n    }\n    function _deconstructPacket(data, buffers) {\n        if (!data)\n            return data;\n        if (isBinary(data)) {\n            const placeholder = { _placeholder: true, num: buffers.length };\n            buffers.push(data);\n            return placeholder;\n        }\n        else if (Array.isArray(data)) {\n            const newData = new Array(data.length);\n            for (let i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i], buffers);\n            }\n            return newData;\n        }\n        else if (typeof data === \"object\" && !(data instanceof Date)) {\n            const newData = {};\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    newData[key] = _deconstructPacket(data[key], buffers);\n                }\n            }\n            return newData;\n        }\n        return data;\n    }\n    /**\n     * Reconstructs a binary packet from its placeholder packet and buffers\n     *\n     * @param {Object} packet - event packet with placeholders\n     * @param {Array} buffers - binary buffers to put in placeholder positions\n     * @return {Object} reconstructed packet\n     * @public\n     */\n    function reconstructPacket(packet, buffers) {\n        packet.data = _reconstructPacket(packet.data, buffers);\n        packet.attachments = undefined; // no longer useful\n        return packet;\n    }\n    function _reconstructPacket(data, buffers) {\n        if (!data)\n            return data;\n        if (data && data._placeholder) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else if (Array.isArray(data)) {\n            for (let i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i], buffers);\n            }\n        }\n        else if (typeof data === \"object\") {\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    data[key] = _reconstructPacket(data[key], buffers);\n                }\n            }\n        }\n        return data;\n    }",
                    "originalLength": 2445,
                    "removedExports": [],
                    "renderedExports": [
                        "deconstructPacket",
                        "reconstructPacket"
                    ],
                    "renderedLength": 2387
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\index.js": {
                    "code": "    /**\n     * Protocol version.\n     *\n     * @public\n     */\n    const protocol = 5;\n    var PacketType;\n    (function (PacketType) {\n        PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n        PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n        PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n        PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n        PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n        PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n        PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n    })(PacketType || (PacketType = {}));\n    /**\n     * A socket.io Encoder instance\n     */\n    class Encoder {\n        /**\n         * Encode a packet as a single string if non-binary, or as a\n         * buffer sequence, depending on packet type.\n         *\n         * @param {Object} obj - packet object\n         */\n        encode(obj) {\n            if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                if (hasBinary(obj)) {\n                    obj.type =\n                        obj.type === PacketType.EVENT\n                            ? PacketType.BINARY_EVENT\n                            : PacketType.BINARY_ACK;\n                    return this.encodeAsBinary(obj);\n                }\n            }\n            return [this.encodeAsString(obj)];\n        }\n        /**\n         * Encode packet as string.\n         */\n        encodeAsString(obj) {\n            // first is type\n            let str = \"\" + obj.type;\n            // attachments if we have them\n            if (obj.type === PacketType.BINARY_EVENT ||\n                obj.type === PacketType.BINARY_ACK) {\n                str += obj.attachments + \"-\";\n            }\n            // if we have a namespace other than `/`\n            // we append it followed by a comma `,`\n            if (obj.nsp && \"/\" !== obj.nsp) {\n                str += obj.nsp + \",\";\n            }\n            // immediately followed by the id\n            if (null != obj.id) {\n                str += obj.id;\n            }\n            // json data\n            if (null != obj.data) {\n                str += JSON.stringify(obj.data);\n            }\n            return str;\n        }\n        /**\n         * Encode packet as 'buffer sequence' by removing blobs, and\n         * deconstructing packet into object with placeholders and\n         * a list of buffers.\n         */\n        encodeAsBinary(obj) {\n            const deconstruction = deconstructPacket(obj);\n            const pack = this.encodeAsString(deconstruction.packet);\n            const buffers = deconstruction.buffers;\n            buffers.unshift(pack); // add packet info to beginning of data list\n            return buffers; // write all the buffers\n        }\n    }\n    /**\n     * A socket.io Decoder instance\n     *\n     * @return {Object} decoder\n     */\n    class Decoder extends Emitter_1 {\n        constructor() {\n            super();\n        }\n        /**\n         * Decodes an encoded packet string into packet JSON.\n         *\n         * @param {String} obj - encoded packet\n         */\n        add(obj) {\n            let packet;\n            if (typeof obj === \"string\") {\n                packet = this.decodeString(obj);\n                if (packet.type === PacketType.BINARY_EVENT ||\n                    packet.type === PacketType.BINARY_ACK) {\n                    // binary packet's json\n                    this.reconstructor = new BinaryReconstructor(packet);\n                    // no attachments, labeled binary but no binary data to follow\n                    if (packet.attachments === 0) {\n                        super.emitReserved(\"decoded\", packet);\n                    }\n                }\n                else {\n                    // non-binary full packet\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else if (isBinary(obj) || obj.base64) {\n                // raw binary data\n                if (!this.reconstructor) {\n                    throw new Error(\"got binary data when not reconstructing a packet\");\n                }\n                else {\n                    packet = this.reconstructor.takeBinaryData(obj);\n                    if (packet) {\n                        // received final buffer\n                        this.reconstructor = null;\n                        super.emitReserved(\"decoded\", packet);\n                    }\n                }\n            }\n            else {\n                throw new Error(\"Unknown type: \" + obj);\n            }\n        }\n        /**\n         * Decode a packet String (JSON data)\n         *\n         * @param {String} str\n         * @return {Object} packet\n         */\n        decodeString(str) {\n            let i = 0;\n            // look up type\n            const p = {\n                type: Number(str.charAt(0)),\n            };\n            if (PacketType[p.type] === undefined) {\n                throw new Error(\"unknown packet type \" + p.type);\n            }\n            // look up attachments if type binary\n            if (p.type === PacketType.BINARY_EVENT ||\n                p.type === PacketType.BINARY_ACK) {\n                const start = i + 1;\n                while (str.charAt(++i) !== \"-\" && i != str.length) { }\n                const buf = str.substring(start, i);\n                if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                    throw new Error(\"Illegal attachments\");\n                }\n                p.attachments = Number(buf);\n            }\n            // look up namespace (if any)\n            if (\"/\" === str.charAt(i + 1)) {\n                const start = i + 1;\n                while (++i) {\n                    const c = str.charAt(i);\n                    if (\",\" === c)\n                        break;\n                    if (i === str.length)\n                        break;\n                }\n                p.nsp = str.substring(start, i);\n            }\n            else {\n                p.nsp = \"/\";\n            }\n            // look up id\n            const next = str.charAt(i + 1);\n            if (\"\" !== next && Number(next) == next) {\n                const start = i + 1;\n                while (++i) {\n                    const c = str.charAt(i);\n                    if (null == c || Number(c) != c) {\n                        --i;\n                        break;\n                    }\n                    if (i === str.length)\n                        break;\n                }\n                p.id = Number(str.substring(start, i + 1));\n            }\n            // look up json data\n            if (str.charAt(++i)) {\n                const payload = tryParse(str.substr(i));\n                if (Decoder.isPayloadValid(p.type, payload)) {\n                    p.data = payload;\n                }\n                else {\n                    throw new Error(\"invalid payload\");\n                }\n            }\n            return p;\n        }\n        static isPayloadValid(type, payload) {\n            switch (type) {\n                case PacketType.CONNECT:\n                    return typeof payload === \"object\";\n                case PacketType.DISCONNECT:\n                    return payload === undefined;\n                case PacketType.CONNECT_ERROR:\n                    return typeof payload === \"string\" || typeof payload === \"object\";\n                case PacketType.EVENT:\n                case PacketType.BINARY_EVENT:\n                    return Array.isArray(payload) && payload.length > 0;\n                case PacketType.ACK:\n                case PacketType.BINARY_ACK:\n                    return Array.isArray(payload);\n            }\n        }\n        /**\n         * Deallocates a parser's resources\n         */\n        destroy() {\n            if (this.reconstructor) {\n                this.reconstructor.finishedReconstruction();\n            }\n        }\n    }\n    function tryParse(str) {\n        try {\n            return JSON.parse(str);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * A manager of a binary event's 'buffer sequence'. Should\n     * be constructed whenever a packet of type BINARY_EVENT is\n     * decoded.\n     *\n     * @param {Object} packet\n     * @return {BinaryReconstructor} initialized reconstructor\n     */\n    class BinaryReconstructor {\n        constructor(packet) {\n            this.packet = packet;\n            this.buffers = [];\n            this.reconPack = packet;\n        }\n        /**\n         * Method to be called when binary data received from connection\n         * after a BINARY_EVENT packet.\n         *\n         * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n         * @return {null | Object} returns null if more binary data is expected or\n         *   a reconstructed packet object if all buffers have been received.\n         */\n        takeBinaryData(binData) {\n            this.buffers.push(binData);\n            if (this.buffers.length === this.reconPack.attachments) {\n                // done with buffer list\n                const packet = reconstructPacket(this.reconPack, this.buffers);\n                this.finishedReconstruction();\n                return packet;\n            }\n            return null;\n        }\n        /**\n         * Cleans up binary packet reconstruction variables.\n         */\n        finishedReconstruction() {\n            this.reconPack = null;\n            this.buffers = [];\n        }\n    }",
                    "originalLength": 8551,
                    "removedExports": [],
                    "renderedExports": [
                        "protocol",
                        "PacketType",
                        "Encoder",
                        "Decoder"
                    ],
                    "renderedLength": 8346
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\on.js": {
                    "code": "    function on(obj, ev, fn) {\n        obj.on(ev, fn);\n        return function subDestroy() {\n            obj.off(ev, fn);\n        };\n    }",
                    "originalLength": 123,
                    "removedExports": [],
                    "renderedExports": [
                        "on"
                    ],
                    "renderedLength": 115
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\socket.js": {
                    "code": "    /**\n     * Internal events.\n     * These events can't be emitted by the user.\n     */\n    const RESERVED_EVENTS = Object.freeze({\n        connect: 1,\n        connect_error: 1,\n        disconnect: 1,\n        disconnecting: 1,\n        // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n        newListener: 1,\n        removeListener: 1,\n    });\n    class Socket extends Emitter_1 {\n        /**\n         * `Socket` constructor.\n         *\n         * @public\n         */\n        constructor(io, nsp, opts) {\n            super();\n            this.connected = false;\n            this.disconnected = true;\n            this.receiveBuffer = [];\n            this.sendBuffer = [];\n            this.ids = 0;\n            this.acks = {};\n            this.flags = {};\n            this.io = io;\n            this.nsp = nsp;\n            if (opts && opts.auth) {\n                this.auth = opts.auth;\n            }\n            if (this.io._autoConnect)\n                this.open();\n        }\n        /**\n         * Subscribe to open, close and packet events\n         *\n         * @private\n         */\n        subEvents() {\n            if (this.subs)\n                return;\n            const io = this.io;\n            this.subs = [\n                on(io, \"open\", this.onopen.bind(this)),\n                on(io, \"packet\", this.onpacket.bind(this)),\n                on(io, \"error\", this.onerror.bind(this)),\n                on(io, \"close\", this.onclose.bind(this)),\n            ];\n        }\n        /**\n         * Whether the Socket will try to reconnect when its Manager connects or reconnects\n         */\n        get active() {\n            return !!this.subs;\n        }\n        /**\n         * \"Opens\" the socket.\n         *\n         * @public\n         */\n        connect() {\n            if (this.connected)\n                return this;\n            this.subEvents();\n            if (!this.io[\"_reconnecting\"])\n                this.io.open(); // ensure open\n            if (\"open\" === this.io._readyState)\n                this.onopen();\n            return this;\n        }\n        /**\n         * Alias for connect()\n         */\n        open() {\n            return this.connect();\n        }\n        /**\n         * Sends a `message` event.\n         *\n         * @return self\n         * @public\n         */\n        send(...args) {\n            args.unshift(\"message\");\n            this.emit.apply(this, args);\n            return this;\n        }\n        /**\n         * Override `emit`.\n         * If the event is in `events`, it's emitted normally.\n         *\n         * @return self\n         * @public\n         */\n        emit(ev, ...args) {\n            if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n                throw new Error('\"' + ev + '\" is a reserved event name');\n            }\n            args.unshift(ev);\n            const packet = {\n                type: PacketType.EVENT,\n                data: args,\n            };\n            packet.options = {};\n            packet.options.compress = this.flags.compress !== false;\n            // event ack callback\n            if (\"function\" === typeof args[args.length - 1]) {\n                this.acks[this.ids] = args.pop();\n                packet.id = this.ids++;\n            }\n            const isTransportWritable = this.io.engine &&\n                this.io.engine.transport &&\n                this.io.engine.transport.writable;\n            const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n            if (discardPacket) ;\n            else if (this.connected) {\n                this.packet(packet);\n            }\n            else {\n                this.sendBuffer.push(packet);\n            }\n            this.flags = {};\n            return this;\n        }\n        /**\n         * Sends a packet.\n         *\n         * @param packet\n         * @private\n         */\n        packet(packet) {\n            packet.nsp = this.nsp;\n            this.io._packet(packet);\n        }\n        /**\n         * Called upon engine `open`.\n         *\n         * @private\n         */\n        onopen() {\n            if (typeof this.auth == \"function\") {\n                this.auth((data) => {\n                    this.packet({ type: PacketType.CONNECT, data });\n                });\n            }\n            else {\n                this.packet({ type: PacketType.CONNECT, data: this.auth });\n            }\n        }\n        /**\n         * Called upon engine or manager `error`.\n         *\n         * @param err\n         * @private\n         */\n        onerror(err) {\n            if (!this.connected) {\n                this.emitReserved(\"connect_error\", err);\n            }\n        }\n        /**\n         * Called upon engine `close`.\n         *\n         * @param reason\n         * @private\n         */\n        onclose(reason) {\n            this.connected = false;\n            this.disconnected = true;\n            delete this.id;\n            this.emitReserved(\"disconnect\", reason);\n        }\n        /**\n         * Called with socket packet.\n         *\n         * @param packet\n         * @private\n         */\n        onpacket(packet) {\n            const sameNamespace = packet.nsp === this.nsp;\n            if (!sameNamespace)\n                return;\n            switch (packet.type) {\n                case PacketType.CONNECT:\n                    if (packet.data && packet.data.sid) {\n                        const id = packet.data.sid;\n                        this.onconnect(id);\n                    }\n                    else {\n                        this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                    }\n                    break;\n                case PacketType.EVENT:\n                    this.onevent(packet);\n                    break;\n                case PacketType.BINARY_EVENT:\n                    this.onevent(packet);\n                    break;\n                case PacketType.ACK:\n                    this.onack(packet);\n                    break;\n                case PacketType.BINARY_ACK:\n                    this.onack(packet);\n                    break;\n                case PacketType.DISCONNECT:\n                    this.ondisconnect();\n                    break;\n                case PacketType.CONNECT_ERROR:\n                    const err = new Error(packet.data.message);\n                    // @ts-ignore\n                    err.data = packet.data.data;\n                    this.emitReserved(\"connect_error\", err);\n                    break;\n            }\n        }\n        /**\n         * Called upon a server event.\n         *\n         * @param packet\n         * @private\n         */\n        onevent(packet) {\n            const args = packet.data || [];\n            if (null != packet.id) {\n                args.push(this.ack(packet.id));\n            }\n            if (this.connected) {\n                this.emitEvent(args);\n            }\n            else {\n                this.receiveBuffer.push(Object.freeze(args));\n            }\n        }\n        emitEvent(args) {\n            if (this._anyListeners && this._anyListeners.length) {\n                const listeners = this._anyListeners.slice();\n                for (const listener of listeners) {\n                    listener.apply(this, args);\n                }\n            }\n            super.emit.apply(this, args);\n        }\n        /**\n         * Produces an ack callback to emit with an event.\n         *\n         * @private\n         */\n        ack(id) {\n            const self = this;\n            let sent = false;\n            return function (...args) {\n                // prevent double callbacks\n                if (sent)\n                    return;\n                sent = true;\n                self.packet({\n                    type: PacketType.ACK,\n                    id: id,\n                    data: args,\n                });\n            };\n        }\n        /**\n         * Called upon a server acknowlegement.\n         *\n         * @param packet\n         * @private\n         */\n        onack(packet) {\n            const ack = this.acks[packet.id];\n            if (\"function\" === typeof ack) {\n                ack.apply(this, packet.data);\n                delete this.acks[packet.id];\n            }\n        }\n        /**\n         * Called upon server connect.\n         *\n         * @private\n         */\n        onconnect(id) {\n            this.id = id;\n            this.connected = true;\n            this.disconnected = false;\n            this.emitBuffered();\n            this.emitReserved(\"connect\");\n        }\n        /**\n         * Emit buffered events (received and emitted).\n         *\n         * @private\n         */\n        emitBuffered() {\n            this.receiveBuffer.forEach((args) => this.emitEvent(args));\n            this.receiveBuffer = [];\n            this.sendBuffer.forEach((packet) => this.packet(packet));\n            this.sendBuffer = [];\n        }\n        /**\n         * Called upon server disconnect.\n         *\n         * @private\n         */\n        ondisconnect() {\n            this.destroy();\n            this.onclose(\"io server disconnect\");\n        }\n        /**\n         * Called upon forced client/server side disconnections,\n         * this method ensures the manager stops tracking us and\n         * that reconnections don't get triggered for this.\n         *\n         * @private\n         */\n        destroy() {\n            if (this.subs) {\n                // clean subscriptions to avoid reconnections\n                this.subs.forEach((subDestroy) => subDestroy());\n                this.subs = undefined;\n            }\n            this.io[\"_destroy\"](this);\n        }\n        /**\n         * Disconnects the socket manually.\n         *\n         * @return self\n         * @public\n         */\n        disconnect() {\n            if (this.connected) {\n                this.packet({ type: PacketType.DISCONNECT });\n            }\n            // remove socket from pool\n            this.destroy();\n            if (this.connected) {\n                // fire events\n                this.onclose(\"io client disconnect\");\n            }\n            return this;\n        }\n        /**\n         * Alias for disconnect()\n         *\n         * @return self\n         * @public\n         */\n        close() {\n            return this.disconnect();\n        }\n        /**\n         * Sets the compress flag.\n         *\n         * @param compress - if `true`, compresses the sending data\n         * @return self\n         * @public\n         */\n        compress(compress) {\n            this.flags.compress = compress;\n            return this;\n        }\n        /**\n         * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n         * ready to send messages.\n         *\n         * @returns self\n         * @public\n         */\n        get volatile() {\n            this.flags.volatile = true;\n            return this;\n        }\n        /**\n         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n         * callback.\n         *\n         * @param listener\n         * @public\n         */\n        onAny(listener) {\n            this._anyListeners = this._anyListeners || [];\n            this._anyListeners.push(listener);\n            return this;\n        }\n        /**\n         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n         * callback. The listener is added to the beginning of the listeners array.\n         *\n         * @param listener\n         * @public\n         */\n        prependAny(listener) {\n            this._anyListeners = this._anyListeners || [];\n            this._anyListeners.unshift(listener);\n            return this;\n        }\n        /**\n         * Removes the listener that will be fired when any event is emitted.\n         *\n         * @param listener\n         * @public\n         */\n        offAny(listener) {\n            if (!this._anyListeners) {\n                return this;\n            }\n            if (listener) {\n                const listeners = this._anyListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                    if (listener === listeners[i]) {\n                        listeners.splice(i, 1);\n                        return this;\n                    }\n                }\n            }\n            else {\n                this._anyListeners = [];\n            }\n            return this;\n        }\n        /**\n         * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n         * e.g. to remove listeners.\n         *\n         * @public\n         */\n        listenersAny() {\n            return this._anyListeners || [];\n        }\n    }",
                    "originalLength": 11408,
                    "removedExports": [],
                    "renderedExports": [
                        "Socket"
                    ],
                    "renderedLength": 11233
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\backo2\\index.js": {
                    "code": "    /**\n     * Expose `Backoff`.\n     */\n\n    var backo2 = Backoff;\n\n    /**\n     * Initialize backoff timer with `opts`.\n     *\n     * - `min` initial timeout in milliseconds [100]\n     * - `max` max timeout [10000]\n     * - `jitter` [0]\n     * - `factor` [2]\n     *\n     * @param {Object} opts\n     * @api public\n     */\n\n    function Backoff(opts) {\n      opts = opts || {};\n      this.ms = opts.min || 100;\n      this.max = opts.max || 10000;\n      this.factor = opts.factor || 2;\n      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n      this.attempts = 0;\n    }\n\n    /**\n     * Return the backoff duration.\n     *\n     * @return {Number}\n     * @api public\n     */\n\n    Backoff.prototype.duration = function(){\n      var ms = this.ms * Math.pow(this.factor, this.attempts++);\n      if (this.jitter) {\n        var rand =  Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n      }\n      return Math.min(ms, this.max) | 0;\n    };\n\n    /**\n     * Reset the number of attempts.\n     *\n     * @api public\n     */\n\n    Backoff.prototype.reset = function(){\n      this.attempts = 0;\n    };\n\n    /**\n     * Set the minimum duration\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setMin = function(min){\n      this.ms = min;\n    };\n\n    /**\n     * Set the maximum duration\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setMax = function(max){\n      this.max = max;\n    };\n\n    /**\n     * Set the jitter\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setJitter = function(jitter){\n      this.jitter = jitter;\n    };",
                    "originalLength": 1399,
                    "removedExports": [],
                    "renderedExports": [
                        "default",
                        "__moduleExports"
                    ],
                    "renderedLength": 1392
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\manager.js": {
                    "code": "    class Manager extends Emitter_1 {\n        constructor(uri, opts) {\n            var _a;\n            super();\n            this.nsps = {};\n            this.subs = [];\n            if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = undefined;\n            }\n            opts = opts || {};\n            opts.path = opts.path || \"/socket.io\";\n            this.opts = opts;\n            installTimerFunctions(this, opts);\n            this.reconnection(opts.reconnection !== false);\n            this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n            this.reconnectionDelay(opts.reconnectionDelay || 1000);\n            this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n            this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n            this.backoff = new backo2({\n                min: this.reconnectionDelay(),\n                max: this.reconnectionDelayMax(),\n                jitter: this.randomizationFactor(),\n            });\n            this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n            this._readyState = \"closed\";\n            this.uri = uri;\n            const _parser = opts.parser || parser;\n            this.encoder = new _parser.Encoder();\n            this.decoder = new _parser.Decoder();\n            this._autoConnect = opts.autoConnect !== false;\n            if (this._autoConnect)\n                this.open();\n        }\n        reconnection(v) {\n            if (!arguments.length)\n                return this._reconnection;\n            this._reconnection = !!v;\n            return this;\n        }\n        reconnectionAttempts(v) {\n            if (v === undefined)\n                return this._reconnectionAttempts;\n            this._reconnectionAttempts = v;\n            return this;\n        }\n        reconnectionDelay(v) {\n            var _a;\n            if (v === undefined)\n                return this._reconnectionDelay;\n            this._reconnectionDelay = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n            return this;\n        }\n        randomizationFactor(v) {\n            var _a;\n            if (v === undefined)\n                return this._randomizationFactor;\n            this._randomizationFactor = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n            return this;\n        }\n        reconnectionDelayMax(v) {\n            var _a;\n            if (v === undefined)\n                return this._reconnectionDelayMax;\n            this._reconnectionDelayMax = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n            return this;\n        }\n        timeout(v) {\n            if (!arguments.length)\n                return this._timeout;\n            this._timeout = v;\n            return this;\n        }\n        /**\n         * Starts trying to reconnect if reconnection is enabled and we have not\n         * started reconnecting yet\n         *\n         * @private\n         */\n        maybeReconnectOnOpen() {\n            // Only try to reconnect if it's the first time we're connecting\n            if (!this._reconnecting &&\n                this._reconnection &&\n                this.backoff.attempts === 0) {\n                // keeps reconnection from firing twice for the same reconnection loop\n                this.reconnect();\n            }\n        }\n        /**\n         * Sets the current transport `socket`.\n         *\n         * @param {Function} fn - optional, callback\n         * @return self\n         * @public\n         */\n        open(fn) {\n            if (~this._readyState.indexOf(\"open\"))\n                return this;\n            this.engine = new Socket$1(this.uri, this.opts);\n            const socket = this.engine;\n            const self = this;\n            this._readyState = \"opening\";\n            this.skipReconnect = false;\n            // emit `open`\n            const openSubDestroy = on(socket, \"open\", function () {\n                self.onopen();\n                fn && fn();\n            });\n            // emit `error`\n            const errorSub = on(socket, \"error\", (err) => {\n                self.cleanup();\n                self._readyState = \"closed\";\n                this.emitReserved(\"error\", err);\n                if (fn) {\n                    fn(err);\n                }\n                else {\n                    // Only do this if there is no fn to handle the error\n                    self.maybeReconnectOnOpen();\n                }\n            });\n            if (false !== this._timeout) {\n                const timeout = this._timeout;\n                if (timeout === 0) {\n                    openSubDestroy(); // prevents a race condition with the 'open' event\n                }\n                // set timer\n                const timer = this.setTimeoutFn(() => {\n                    openSubDestroy();\n                    socket.close();\n                    // @ts-ignore\n                    socket.emit(\"error\", new Error(\"timeout\"));\n                }, timeout);\n                if (this.opts.autoUnref) {\n                    timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                    clearTimeout(timer);\n                });\n            }\n            this.subs.push(openSubDestroy);\n            this.subs.push(errorSub);\n            return this;\n        }\n        /**\n         * Alias for open()\n         *\n         * @return self\n         * @public\n         */\n        connect(fn) {\n            return this.open(fn);\n        }\n        /**\n         * Called upon transport open.\n         *\n         * @private\n         */\n        onopen() {\n            // clear old subs\n            this.cleanup();\n            // mark as open\n            this._readyState = \"open\";\n            this.emitReserved(\"open\");\n            // add new subs\n            const socket = this.engine;\n            this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n        }\n        /**\n         * Called upon a ping.\n         *\n         * @private\n         */\n        onping() {\n            this.emitReserved(\"ping\");\n        }\n        /**\n         * Called with data.\n         *\n         * @private\n         */\n        ondata(data) {\n            this.decoder.add(data);\n        }\n        /**\n         * Called when parser fully decodes a packet.\n         *\n         * @private\n         */\n        ondecoded(packet) {\n            this.emitReserved(\"packet\", packet);\n        }\n        /**\n         * Called upon socket error.\n         *\n         * @private\n         */\n        onerror(err) {\n            this.emitReserved(\"error\", err);\n        }\n        /**\n         * Creates a new socket for the given `nsp`.\n         *\n         * @return {Socket}\n         * @public\n         */\n        socket(nsp, opts) {\n            let socket = this.nsps[nsp];\n            if (!socket) {\n                socket = new Socket(this, nsp, opts);\n                this.nsps[nsp] = socket;\n            }\n            return socket;\n        }\n        /**\n         * Called upon a socket close.\n         *\n         * @param socket\n         * @private\n         */\n        _destroy(socket) {\n            const nsps = Object.keys(this.nsps);\n            for (const nsp of nsps) {\n                const socket = this.nsps[nsp];\n                if (socket.active) {\n                    return;\n                }\n            }\n            this._close();\n        }\n        /**\n         * Writes a packet.\n         *\n         * @param packet\n         * @private\n         */\n        _packet(packet) {\n            const encodedPackets = this.encoder.encode(packet);\n            for (let i = 0; i < encodedPackets.length; i++) {\n                this.engine.write(encodedPackets[i], packet.options);\n            }\n        }\n        /**\n         * Clean up transport subscriptions and packet buffer.\n         *\n         * @private\n         */\n        cleanup() {\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs.length = 0;\n            this.decoder.destroy();\n        }\n        /**\n         * Close the current socket.\n         *\n         * @private\n         */\n        _close() {\n            this.skipReconnect = true;\n            this._reconnecting = false;\n            if (\"opening\" === this._readyState) {\n                // `onclose` will not fire because\n                // an open event never happened\n                this.cleanup();\n            }\n            this.backoff.reset();\n            this._readyState = \"closed\";\n            if (this.engine)\n                this.engine.close();\n        }\n        /**\n         * Alias for close()\n         *\n         * @private\n         */\n        disconnect() {\n            return this._close();\n        }\n        /**\n         * Called upon engine close.\n         *\n         * @private\n         */\n        onclose(reason) {\n            this.cleanup();\n            this.backoff.reset();\n            this._readyState = \"closed\";\n            this.emitReserved(\"close\", reason);\n            if (this._reconnection && !this.skipReconnect) {\n                this.reconnect();\n            }\n        }\n        /**\n         * Attempt a reconnection.\n         *\n         * @private\n         */\n        reconnect() {\n            if (this._reconnecting || this.skipReconnect)\n                return this;\n            const self = this;\n            if (this.backoff.attempts >= this._reconnectionAttempts) {\n                this.backoff.reset();\n                this.emitReserved(\"reconnect_failed\");\n                this._reconnecting = false;\n            }\n            else {\n                const delay = this.backoff.duration();\n                this._reconnecting = true;\n                const timer = this.setTimeoutFn(() => {\n                    if (self.skipReconnect)\n                        return;\n                    this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                    // check again for the case socket closed in above events\n                    if (self.skipReconnect)\n                        return;\n                    self.open((err) => {\n                        if (err) {\n                            self._reconnecting = false;\n                            self.reconnect();\n                            this.emitReserved(\"reconnect_error\", err);\n                        }\n                        else {\n                            self.onreconnect();\n                        }\n                    });\n                }, delay);\n                if (this.opts.autoUnref) {\n                    timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                    clearTimeout(timer);\n                });\n            }\n        }\n        /**\n         * Called upon successful reconnect.\n         *\n         * @private\n         */\n        onreconnect() {\n            const attempt = this.backoff.attempts;\n            this._reconnecting = false;\n            this.backoff.reset();\n            this.emitReserved(\"reconnect\", attempt);\n        }\n    }",
                    "originalLength": 10204,
                    "removedExports": [],
                    "renderedExports": [
                        "Manager"
                    ],
                    "renderedLength": 9923
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\index.js": {
                    "code": "    /**\n     * Managers cache.\n     */\n    const cache = {};\n    function lookup(uri, opts) {\n        if (typeof uri === \"object\") {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        const parsed = url(uri, opts.path || \"/socket.io\");\n        const source = parsed.source;\n        const id = parsed.id;\n        const path = parsed.path;\n        const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n        const newConnection = opts.forceNew ||\n            opts[\"force new connection\"] ||\n            false === opts.multiplex ||\n            sameNamespace;\n        let io;\n        if (newConnection) {\n            io = new Manager(source, opts);\n        }\n        else {\n            if (!cache[id]) {\n                cache[id] = new Manager(source, opts);\n            }\n            io = cache[id];\n        }\n        if (parsed.query && !opts.query) {\n            opts.query = parsed.queryKey;\n        }\n        return io.socket(parsed.path, opts);\n    }\n    // so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n    // namespace (e.g. `io.connect(...)`), for backward compatibility\n    Object.assign(lookup, {\n        Manager,\n        Socket,\n        io: lookup,\n        connect: lookup,\n    });",
                    "originalLength": 1453,
                    "removedExports": [],
                    "renderedExports": [
                        "Manager",
                        "Socket",
                        "io",
                        "connect",
                        "default"
                    ],
                    "renderedLength": 1106
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.svelte": {
                    "code": "    /* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\n    const { console: console_1 } = globals;\n    const file$1 = \"src\\\\components\\\\chat.svelte\";\n\n    function get_each_context(ctx, list, i) {\n    \tconst child_ctx = ctx.slice();\n    \tchild_ctx[8] = list[i];\n    \tchild_ctx[10] = i;\n    \treturn child_ctx;\n    }\n\n    // (237:4) {#each chatHistory as chatMessage, i}\n    function create_each_block(ctx) {\n    \tlet div;\n    \tlet h4;\n    \tlet t0_value = /*chatMessage*/ ctx[8].user + \"\";\n    \tlet t0;\n    \tlet t1;\n    \tlet p;\n    \tlet t2_value = /*chatMessage*/ ctx[8].msg + \"\";\n    \tlet t2;\n    \tlet t3;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tdiv = element(\"div\");\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt0 = text(t0_value);\n    \t\t\tt1 = space();\n    \t\t\tp = element(\"p\");\n    \t\t\tt2 = text(t2_value);\n    \t\t\tt3 = space();\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tdiv = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div_nodes = children(div);\n    \t\t\th4 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt0 = claim_text(h4_nodes, t0_value);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(div_nodes);\n    \t\t\tp = claim_element(div_nodes, \"P\", { class: true });\n    \t\t\tvar p_nodes = children(p);\n    \t\t\tt2 = claim_text(p_nodes, t2_value);\n    \t\t\tp_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div_nodes);\n    \t\t\tdiv_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(h4, file$1, 238, 12, 5081);\n    \t\t\tattr_dev(p, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(p, file$1, 239, 12, 5122);\n    \t\t\tattr_dev(div, \"class\", \"client-message svelte-127bm7n\");\n    \t\t\tadd_location(div, file$1, 237, 8, 5039);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, div, anchor);\n    \t\t\tappend_hydration_dev(div, h4);\n    \t\t\tappend_hydration_dev(h4, t0);\n    \t\t\tappend_hydration_dev(div, t1);\n    \t\t\tappend_hydration_dev(div, p);\n    \t\t\tappend_hydration_dev(p, t2);\n    \t\t\tappend_hydration_dev(div, t3);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*chatHistory*/ 1 && t0_value !== (t0_value = /*chatMessage*/ ctx[8].user + \"\")) set_data_dev(t0, t0_value);\n    \t\t\tif (dirty & /*chatHistory*/ 1 && t2_value !== (t2_value = /*chatMessage*/ ctx[8].msg + \"\")) set_data_dev(t2, t2_value);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(div);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_each_block.name,\n    \t\ttype: \"each\",\n    \t\tsource: \"(237:4) {#each chatHistory as chatMessage, i}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function create_fragment$1(ctx) {\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div0;\n    \tlet t2;\n    \tlet div1;\n    \tlet fieldset;\n    \tlet t3;\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n    \tlet each_value = /*chatHistory*/ ctx[0];\n    \tvalidate_each_argument(each_value);\n    \tlet each_blocks = [];\n\n    \tfor (let i = 0; i < each_value.length; i += 1) {\n    \t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    \t}\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"CHAT\");\n    \t\t\tt1 = space();\n    \t\t\tdiv0 = element(\"div\");\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].c();\n    \t\t\t}\n\n    \t\t\tt2 = space();\n    \t\t\tdiv1 = element(\"div\");\n    \t\t\tfieldset = element(\"fieldset\");\n    \t\t\tt3 = space();\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"CHAT\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(nodes);\n    \t\t\tdiv0 = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div0_nodes = children(div0);\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].l(div0_nodes);\n    \t\t\t}\n\n    \t\t\tdiv0_nodes.forEach(detach_dev);\n    \t\t\tt2 = claim_space(nodes);\n    \t\t\tdiv1 = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div1_nodes = children(div1);\n    \t\t\tfieldset = claim_element(div1_nodes, \"FIELDSET\", { contenteditable: true, class: true });\n    \t\t\tchildren(fieldset).forEach(detach_dev);\n    \t\t\tt3 = claim_space(div1_nodes);\n\n    \t\t\tsvg = claim_svg_element(div1_nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\twidth: true,\n    \t\t\t\theight: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tclass: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\tid: true,\n    \t\t\t\t\"data-name\": true,\n    \t\t\t\td: true,\n    \t\t\t\ttransform: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tdiv1_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(h1, file$1, 233, 0, 4946);\n    \t\t\tattr_dev(div0, \"class\", \"chat-view svelte-127bm7n\");\n    \t\t\tadd_location(div0, file$1, 235, 0, 4963);\n    \t\t\tattr_dev(fieldset, \"contenteditable\", \"true\");\n    \t\t\tattr_dev(fieldset, \"class\", \"svelte-127bm7n\");\n    \t\t\tif (/*newMessage*/ ctx[1] === void 0) add_render_callback(() => /*fieldset_input_handler*/ ctx[3].call(fieldset));\n    \t\t\tadd_location(fieldset, file$1, 245, 4, 5218);\n    \t\t\tattr_dev(path, \"id\", \"Path_3\");\n    \t\t\tattr_dev(path, \"data-name\", \"Path 3\");\n    \t\t\tattr_dev(path, \"d\", \"M45.912.281,1.215,26.067a2.316,2.316,0,0,0,.212,4.166l10.251,4.3L39.383,10.117a.578.578,0,0,1,.829.8l-23.231,28.3v7.763a2.314,2.314,0,0,0,4.1,1.524L27.2,41.053l12.016,5.034A2.321,2.321,0,0,0,42.4,44.332L49.345,2.672A2.315,2.315,0,0,0,45.912.281Z\");\n    \t\t\tattr_dev(path, \"transform\", \"translate(-0.01 0.031)\");\n    \t\t\tattr_dev(path, \"fill\", \"#1e88e5\");\n    \t\t\tadd_location(path, file$1, 247, 8, 5429);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"width\", \"49.369\");\n    \t\t\tattr_dev(svg, \"height\", \"49.384\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 49.369 49.384\");\n    \t\t\tattr_dev(svg, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(svg, file$1, 246, 4, 5289);\n    \t\t\tattr_dev(div1, \"class\", \"message-box svelte-127bm7n\");\n    \t\t\tadd_location(div1, file$1, 244, 0, 5187);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h1, anchor);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tinsert_hydration_dev(target, t1, anchor);\n    \t\t\tinsert_hydration_dev(target, div0, anchor);\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].m(div0, null);\n    \t\t\t}\n\n    \t\t\tinsert_hydration_dev(target, t2, anchor);\n    \t\t\tinsert_hydration_dev(target, div1, anchor);\n    \t\t\tappend_hydration_dev(div1, fieldset);\n\n    \t\t\tif (/*newMessage*/ ctx[1] !== void 0) {\n    \t\t\t\tfieldset.textContent = /*newMessage*/ ctx[1];\n    \t\t\t}\n\n    \t\t\tappend_hydration_dev(div1, t3);\n    \t\t\tappend_hydration_dev(div1, svg);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = [\n    \t\t\t\t\tlisten_dev(fieldset, \"input\", /*fieldset_input_handler*/ ctx[3]),\n    \t\t\t\t\tlisten_dev(svg, \"click\", /*click_handler*/ ctx[4], false, false, false)\n    \t\t\t\t];\n\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tif (dirty & /*chatHistory*/ 1) {\n    \t\t\t\teach_value = /*chatHistory*/ ctx[0];\n    \t\t\t\tvalidate_each_argument(each_value);\n    \t\t\t\tlet i;\n\n    \t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n    \t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n    \t\t\t\t\tif (each_blocks[i]) {\n    \t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n    \t\t\t\t\t\teach_blocks[i].c();\n    \t\t\t\t\t\teach_blocks[i].m(div0, null);\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\tfor (; i < each_blocks.length; i += 1) {\n    \t\t\t\t\teach_blocks[i].d(1);\n    \t\t\t\t}\n\n    \t\t\t\teach_blocks.length = each_value.length;\n    \t\t\t}\n\n    \t\t\tif (dirty & /*newMessage*/ 2 && /*newMessage*/ ctx[1] !== fieldset.textContent) {\n    \t\t\t\tfieldset.textContent = /*newMessage*/ ctx[1];\n    \t\t\t}\n    \t\t},\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h1);\n    \t\t\tif (detaching) detach_dev(t1);\n    \t\t\tif (detaching) detach_dev(div0);\n    \t\t\tdestroy_each(each_blocks, detaching);\n    \t\t\tif (detaching) detach_dev(t2);\n    \t\t\tif (detaching) detach_dev(div1);\n    \t\t\tmounted = false;\n    \t\t\trun_all(dispose);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment$1.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance$1($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Chat', slots, []);\n    \tconst socket = lookup(\"localhost:3002\");\n    \tlet { chatHistory = [] } = $$props;\n\n    \t// Client socket callback that occurs on connection to server. \n    \tsocket.on(\"connect\", () => {\n    \t\t// either with send()  socket.send(\"Hello!\");\n    \t\t// or with emit() and custom event names \n    \t\t//let clientConnected = `CLIENT connected from ...`;\n    \t\t//socket.emit(\"clientConnect\", clientConnected);\n    \t\tconsole.log(\"Connected to server\");\n\n    \t\t// Client socket listening to specific key emit from server socket\n    \t\tsocket.on(\"serverMessage\", (user, msg) => {\n    \t\t\tAddMessage(user, msg);\n\n    \t\t\t// Force update so reactivity works\n    \t\t\t$$invalidate(0, chatHistory);\n    \t\t});\n    \t});\n\n    \tconst AddMessage = (user, msg) => {\n    \t\tlet chatObj = { user, msg };\n    \t\tchatHistory.push(chatObj);\n\n    \t\t// Clientside logging\n    \t\tconsole.log(\"Client Message: \" + msg);\n    \t};\n\n    \tlet username = \"Guest\";\n    \tlet newMessage = \"\";\n\n    \t/* Example request for a server emit\r\n    const TestData = async() => {\r\n        let response = await fetch(\"/test\");\r\n        if(!response.ok) return console.error(\"ERROR FETCH\");\r\n    }\r\n    */\n    \t//socket.emit(\"clientMessage\", newMessage);\n    \tconst SendMessage = async () => {\n    \t\tlet msgObj = { username, newMessage };\n\n    \t\tlet response = await fetch(\"/chat/message\", {\n    \t\t\tmethod: \"POST\",\n    \t\t\theaders: {\n    \t\t\t\t\"Content-Type\": \"application/json;charset=utf-8\"\n    \t\t\t},\n    \t\t\tbody: JSON.stringify(msgObj)\n    \t\t});\n\n    \t\tif (!response.ok) return console.error(\"Could not send message!\");\n    \t\tresponse.text();\n    \t}; //console.log(result);\n\n    \tconst writable_props = ['chatHistory'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Chat> was created with unknown prop '${key}'`);\n    \t});\n\n    \tfunction fieldset_input_handler() {\n    \t\tnewMessage = this.textContent;\n    \t\t$$invalidate(1, newMessage);\n    \t}\n\n    \tconst click_handler = () => SendMessage();\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \t$$self.$capture_state = () => ({\n    \t\tio: lookup,\n    \t\tsocket,\n    \t\tchatHistory,\n    \t\tAddMessage,\n    \t\tusername,\n    \t\tnewMessage,\n    \t\tSendMessage\n    \t});\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t\tif ('username' in $$props) username = $$props.username;\n    \t\tif ('newMessage' in $$props) $$invalidate(1, newMessage = $$props.newMessage);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \t$$self.$$.update = () => {\n    \t\tif ($$self.$$.dirty & /*chatHistory*/ 1) ;\n    \t};\n\n    \treturn [chatHistory, newMessage, SendMessage, fieldset_input_handler, click_handler];\n    }\n\n    class Chat extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance$1, create_fragment$1, safe_not_equal, { chatHistory: 0 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Chat\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment$1.name\n    \t\t});\n    \t}\n\n    \tget chatHistory() {\n    \t\tthrow new Error(\"<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset chatHistory(value) {\n    \t\tthrow new Error(\"<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }",
                    "originalLength": 6778,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 11270
                },
                "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte": {
                    "code": "    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet chat;\n    \tlet t0;\n    \tlet footer;\n    \tlet t1;\n    \tlet a;\n    \tlet t2;\n    \tlet current;\n\n    \tchat = new Chat({\n    \t\t\tprops: { chatHistory: /*chatHistory*/ ctx[0] },\n    \t\t\t$$inline: true\n    \t\t});\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\tcreate_component(chat.$$.fragment);\n    \t\t\tt0 = space();\n    \t\t\tfooter = element(\"footer\");\n    \t\t\tt1 = text(\"Copyright 2021 - \");\n    \t\t\ta = element(\"a\");\n    \t\t\tt2 = text(\"ignurof.xyz\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\tclaim_component(chat.$$.fragment, main_nodes);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tt0 = claim_space(nodes);\n    \t\t\tfooter = claim_element(nodes, \"FOOTER\", { class: true });\n    \t\t\tvar footer_nodes = children(footer);\n    \t\t\tt1 = claim_text(footer_nodes, \"Copyright 2021 - \");\n    \t\t\ta = claim_element(footer_nodes, \"A\", { href: true, target: true, class: true });\n    \t\t\tvar a_nodes = children(a);\n    \t\t\tt2 = claim_text(a_nodes, \"ignurof.xyz\");\n    \t\t\ta_nodes.forEach(detach_dev);\n    \t\t\tfooter_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(main, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(main, file, 47, 0, 796);\n    \t\t\tattr_dev(a, \"href\", \"https://ignurof.xyz\");\n    \t\t\tattr_dev(a, \"target\", \"_blank\");\n    \t\t\tattr_dev(a, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(a, file, 51, 21, 871);\n    \t\t\tattr_dev(footer, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(footer, file, 50, 0, 840);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tmount_component(chat, main, null);\n    \t\t\tinsert_hydration_dev(target, t0, anchor);\n    \t\t\tinsert_hydration_dev(target, footer, anchor);\n    \t\t\tappend_hydration_dev(footer, t1);\n    \t\t\tappend_hydration_dev(footer, a);\n    \t\t\tappend_hydration_dev(a, t2);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tconst chat_changes = {};\n    \t\t\tif (dirty & /*chatHistory*/ 1) chat_changes.chatHistory = /*chatHistory*/ ctx[0];\n    \t\t\tchat.$set(chat_changes);\n    \t\t},\n    \t\ti: function intro(local) {\n    \t\t\tif (current) return;\n    \t\t\ttransition_in(chat.$$.fragment, local);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\to: function outro(local) {\n    \t\t\ttransition_out(chat.$$.fragment, local);\n    \t\t\tcurrent = false;\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t\tdestroy_component(chat);\n    \t\t\tif (detaching) detach_dev(t0);\n    \t\t\tif (detaching) detach_dev(footer);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { chatHistory = [] } = $$props;\n    \tconst writable_props = ['chatHistory'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \t$$self.$capture_state = () => ({ Chat, chatHistory });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [chatHistory];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { chatHistory: 0 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n    \t}\n\n    \tget chatHistory() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset chatHistory(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }",
                    "originalLength": 1204,
                    "removedExports": [],
                    "renderedExports": [
                        "default"
                    ],
                    "renderedLength": 4159
                }
            },
            "name": "index",
            "type": "chunk",
            "code": "var Index = (function () {\n    'use strict';\n\n    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function destroy_each(iterations, detaching) {\n        for (let i = 0; i < iterations.length; i += 1) {\n            if (iterations[i])\n                iterations[i].d(detaching);\n        }\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function svg_element(name) {\n        return document.createElementNS('http://www.w3.org/2000/svg', name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function listen(node, event, handler, options) {\n        node.addEventListener(event, handler, options);\n        return () => node.removeEventListener(event, handler, options);\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_svg_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, svg_element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    let outros;\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function transition_out(block, local, detach, callback) {\n        if (block && block.o) {\n            if (outroing.has(block))\n                return;\n            outroing.add(block);\n            outros.c.push(() => {\n                outroing.delete(block);\n                if (callback) {\n                    if (detach)\n                        block.d(1);\n                    callback();\n                }\n            });\n            block.o(local);\n        }\n    }\n\n    const globals = (typeof window !== 'undefined'\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : global);\n    function create_component(block) {\n        block && block.c();\n    }\n    function claim_component(block, parent_nodes) {\n        block && block.l(parent_nodes);\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.1' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n        if (has_prevent_default)\n            modifiers.push('preventDefault');\n        if (has_stop_propagation)\n            modifiers.push('stopPropagation');\n        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n        const dispose = listen(node, event, handler, options);\n        return () => {\n            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n            dispose();\n        };\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function set_data_dev(text, data) {\n        data = '' + data;\n        if (text.wholeText === data)\n            return;\n        dispatch_dev('SvelteDOMSetData', { node: text, data });\n        text.data = data;\n    }\n    function validate_each_argument(arg) {\n        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n            let msg = '{#each} only iterates over array-like objects.';\n            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n                msg += ' You can use a spread to convert this iterable into an array.';\n            }\n            throw new Error(msg);\n        }\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }\n\n    /**\n     * Parses an URI\n     *\n     * @author Steven Levithan <stevenlevithan.com> (MIT license)\n     * @api private\n     */\n\n    var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n    var parts = [\n        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n    ];\n\n    var parseuri = function parseuri(str) {\n        var src = str,\n            b = str.indexOf('['),\n            e = str.indexOf(']');\n\n        if (b != -1 && e != -1) {\n            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n        }\n\n        var m = re.exec(str || ''),\n            uri = {},\n            i = 14;\n\n        while (i--) {\n            uri[parts[i]] = m[i] || '';\n        }\n\n        if (b != -1 && e != -1) {\n            uri.source = src;\n            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n            uri.ipv6uri = true;\n        }\n\n        uri.pathNames = pathNames(uri, uri['path']);\n        uri.queryKey = queryKey(uri, uri['query']);\n\n        return uri;\n    };\n\n    function pathNames(obj, path) {\n        var regx = /\\/{2,9}/g,\n            names = path.replace(regx, \"/\").split(\"/\");\n\n        if (path.substr(0, 1) == '/' || path.length === 0) {\n            names.splice(0, 1);\n        }\n        if (path.substr(path.length - 1, 1) == '/') {\n            names.splice(names.length - 1, 1);\n        }\n\n        return names;\n    }\n\n    function queryKey(uri, query) {\n        var data = {};\n\n        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n            if ($1) {\n                data[$1] = $2;\n            }\n        });\n\n        return data;\n    }\n\n    /**\n     * URL parser.\n     *\n     * @param uri - url\n     * @param path - the request path of the connection\n     * @param loc - An object meant to mimic window.location.\n     *        Defaults to window.location.\n     * @public\n     */\n    function url(uri, path = \"\", loc) {\n        let obj = uri;\n        // default to window.location\n        loc = loc || (typeof location !== \"undefined\" && location);\n        if (null == uri)\n            uri = loc.protocol + \"//\" + loc.host;\n        // relative path support\n        if (typeof uri === \"string\") {\n            if (\"/\" === uri.charAt(0)) {\n                if (\"/\" === uri.charAt(1)) {\n                    uri = loc.protocol + uri;\n                }\n                else {\n                    uri = loc.host + uri;\n                }\n            }\n            if (!/^(https?|wss?):\\/\\//.test(uri)) {\n                if (\"undefined\" !== typeof loc) {\n                    uri = loc.protocol + \"//\" + uri;\n                }\n                else {\n                    uri = \"https://\" + uri;\n                }\n            }\n            // parse\n            obj = parseuri(uri);\n        }\n        // make sure we treat `localhost:80` and `localhost` equally\n        if (!obj.port) {\n            if (/^(http|ws)$/.test(obj.protocol)) {\n                obj.port = \"80\";\n            }\n            else if (/^(http|ws)s$/.test(obj.protocol)) {\n                obj.port = \"443\";\n            }\n        }\n        obj.path = obj.path || \"/\";\n        const ipv6 = obj.host.indexOf(\":\") !== -1;\n        const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n        // define unique id\n        obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n        // define href\n        obj.href =\n            obj.protocol +\n                \"://\" +\n                host +\n                (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n        return obj;\n    }\n\n    var hasCors = {exports: {}};\n\n    /**\n     * Module exports.\n     *\n     * Logic borrowed from Modernizr:\n     *\n     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n     */\n\n    try {\n      hasCors.exports = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n    } catch (err) {\n      // if XMLHttp support is disabled in IE then it will throw\n      // when trying to create\n      hasCors.exports = false;\n    }\n\n    var hasCORS = hasCors.exports;\n\n    var globalThis$1 = (() => {\n        if (typeof self !== \"undefined\") {\n            return self;\n        }\n        else if (typeof window !== \"undefined\") {\n            return window;\n        }\n        else {\n            return Function(\"return this\")();\n        }\n    })();\n\n    // browser shim for xmlhttprequest module\n    function XMLHttpRequest$1 (opts) {\n        const xdomain = opts.xdomain;\n        // XMLHttpRequest can be disabled on IE\n        try {\n            if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n                return new XMLHttpRequest();\n            }\n        }\n        catch (e) { }\n        if (!xdomain) {\n            try {\n                return new globalThis$1[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n            }\n            catch (e) { }\n        }\n    }\n\n    function pick(obj, ...attr) {\n        return attr.reduce((acc, k) => {\n            if (obj.hasOwnProperty(k)) {\n                acc[k] = obj[k];\n            }\n            return acc;\n        }, {});\n    }\n    // Keep a reference to the real timeout functions so they can be used when overridden\n    const NATIVE_SET_TIMEOUT = setTimeout;\n    const NATIVE_CLEAR_TIMEOUT = clearTimeout;\n    function installTimerFunctions(obj, opts) {\n        if (opts.useNativeTimers) {\n            obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis$1);\n            obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis$1);\n        }\n        else {\n            obj.setTimeoutFn = setTimeout.bind(globalThis$1);\n            obj.clearTimeoutFn = clearTimeout.bind(globalThis$1);\n        }\n    }\n\n    /**\n     * Expose `Emitter`.\n     */\n\n    var Emitter_1 = Emitter;\n\n    /**\n     * Initialize a new `Emitter`.\n     *\n     * @api public\n     */\n\n    function Emitter(obj) {\n      if (obj) return mixin(obj);\n    }\n\n    /**\n     * Mixin the emitter properties.\n     *\n     * @param {Object} obj\n     * @return {Object}\n     * @api private\n     */\n\n    function mixin(obj) {\n      for (var key in Emitter.prototype) {\n        obj[key] = Emitter.prototype[key];\n      }\n      return obj;\n    }\n\n    /**\n     * Listen on the given `event` with `fn`.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.on =\n    Emitter.prototype.addEventListener = function(event, fn){\n      this._callbacks = this._callbacks || {};\n      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n        .push(fn);\n      return this;\n    };\n\n    /**\n     * Adds an `event` listener that will be invoked a single\n     * time then automatically removed.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.once = function(event, fn){\n      function on() {\n        this.off(event, on);\n        fn.apply(this, arguments);\n      }\n\n      on.fn = fn;\n      this.on(event, on);\n      return this;\n    };\n\n    /**\n     * Remove the given callback for `event` or all\n     * registered callbacks.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     * @return {Emitter}\n     * @api public\n     */\n\n    Emitter.prototype.off =\n    Emitter.prototype.removeListener =\n    Emitter.prototype.removeAllListeners =\n    Emitter.prototype.removeEventListener = function(event, fn){\n      this._callbacks = this._callbacks || {};\n\n      // all\n      if (0 == arguments.length) {\n        this._callbacks = {};\n        return this;\n      }\n\n      // specific event\n      var callbacks = this._callbacks['$' + event];\n      if (!callbacks) return this;\n\n      // remove all handlers\n      if (1 == arguments.length) {\n        delete this._callbacks['$' + event];\n        return this;\n      }\n\n      // remove specific handler\n      var cb;\n      for (var i = 0; i < callbacks.length; i++) {\n        cb = callbacks[i];\n        if (cb === fn || cb.fn === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n\n      // Remove event specific arrays for event types that no\n      // one is subscribed for to avoid memory leak.\n      if (callbacks.length === 0) {\n        delete this._callbacks['$' + event];\n      }\n\n      return this;\n    };\n\n    /**\n     * Emit `event` with the given args.\n     *\n     * @param {String} event\n     * @param {Mixed} ...\n     * @return {Emitter}\n     */\n\n    Emitter.prototype.emit = function(event){\n      this._callbacks = this._callbacks || {};\n\n      var args = new Array(arguments.length - 1)\n        , callbacks = this._callbacks['$' + event];\n\n      for (var i = 1; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      if (callbacks) {\n        callbacks = callbacks.slice(0);\n        for (var i = 0, len = callbacks.length; i < len; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n\n      return this;\n    };\n\n    // alias used for reserved events (protected method)\n    Emitter.prototype.emitReserved = Emitter.prototype.emit;\n\n    /**\n     * Return array of callbacks for `event`.\n     *\n     * @param {String} event\n     * @return {Array}\n     * @api public\n     */\n\n    Emitter.prototype.listeners = function(event){\n      this._callbacks = this._callbacks || {};\n      return this._callbacks['$' + event] || [];\n    };\n\n    /**\n     * Check if this emitter has `event` handlers.\n     *\n     * @param {String} event\n     * @return {Boolean}\n     * @api public\n     */\n\n    Emitter.prototype.hasListeners = function(event){\n      return !! this.listeners(event).length;\n    };\n\n    const PACKET_TYPES = Object.create(null); // no Map = no polyfill\n    PACKET_TYPES[\"open\"] = \"0\";\n    PACKET_TYPES[\"close\"] = \"1\";\n    PACKET_TYPES[\"ping\"] = \"2\";\n    PACKET_TYPES[\"pong\"] = \"3\";\n    PACKET_TYPES[\"message\"] = \"4\";\n    PACKET_TYPES[\"upgrade\"] = \"5\";\n    PACKET_TYPES[\"noop\"] = \"6\";\n    const PACKET_TYPES_REVERSE = Object.create(null);\n    Object.keys(PACKET_TYPES).forEach(key => {\n        PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n    });\n    const ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\n    const withNativeBlob$1 = typeof Blob === \"function\" ||\n        (typeof Blob !== \"undefined\" &&\n            Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\n    const withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\n    // ArrayBuffer.isView method is not defined in IE10\n    const isView$1 = obj => {\n        return typeof ArrayBuffer.isView === \"function\"\n            ? ArrayBuffer.isView(obj)\n            : obj && obj.buffer instanceof ArrayBuffer;\n    };\n    const encodePacket = ({ type, data }, supportsBinary, callback) => {\n        if (withNativeBlob$1 && data instanceof Blob) {\n            if (supportsBinary) {\n                return callback(data);\n            }\n            else {\n                return encodeBlobAsBase64(data, callback);\n            }\n        }\n        else if (withNativeArrayBuffer$2 &&\n            (data instanceof ArrayBuffer || isView$1(data))) {\n            if (supportsBinary) {\n                return callback(data);\n            }\n            else {\n                return encodeBlobAsBase64(new Blob([data]), callback);\n            }\n        }\n        // plain string\n        return callback(PACKET_TYPES[type] + (data || \"\"));\n    };\n    const encodeBlobAsBase64 = (data, callback) => {\n        const fileReader = new FileReader();\n        fileReader.onload = function () {\n            const content = fileReader.result.split(\",\")[1];\n            callback(\"b\" + content);\n        };\n        return fileReader.readAsDataURL(data);\n    };\n\n    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i$1 = 0; i$1 < chars.length; i$1++) {\n        lookup$1[chars.charCodeAt(i$1)] = i$1;\n    }\n    var decode$1 = function (base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === '=') {\n            bufferLength--;\n            if (base64[base64.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n        for (i = 0; i < len; i += 4) {\n            encoded1 = lookup$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n        return arraybuffer;\n    };\n\n    const withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\n    const decodePacket = (encodedPacket, binaryType) => {\n        if (typeof encodedPacket !== \"string\") {\n            return {\n                type: \"message\",\n                data: mapBinary(encodedPacket, binaryType)\n            };\n        }\n        const type = encodedPacket.charAt(0);\n        if (type === \"b\") {\n            return {\n                type: \"message\",\n                data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n            };\n        }\n        const packetType = PACKET_TYPES_REVERSE[type];\n        if (!packetType) {\n            return ERROR_PACKET;\n        }\n        return encodedPacket.length > 1\n            ? {\n                type: PACKET_TYPES_REVERSE[type],\n                data: encodedPacket.substring(1)\n            }\n            : {\n                type: PACKET_TYPES_REVERSE[type]\n            };\n    };\n    const decodeBase64Packet = (data, binaryType) => {\n        if (withNativeArrayBuffer$1) {\n            const decoded = decode$1(data);\n            return mapBinary(decoded, binaryType);\n        }\n        else {\n            return { base64: true, data }; // fallback for old browsers\n        }\n    };\n    const mapBinary = (data, binaryType) => {\n        switch (binaryType) {\n            case \"blob\":\n                return data instanceof ArrayBuffer ? new Blob([data]) : data;\n            case \"arraybuffer\":\n            default:\n                return data; // assuming the data is already an ArrayBuffer\n        }\n    };\n\n    const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n    const encodePayload = (packets, callback) => {\n        // some packets may be added to the array while encoding, so the initial length must be saved\n        const length = packets.length;\n        const encodedPackets = new Array(length);\n        let count = 0;\n        packets.forEach((packet, i) => {\n            // force base64 encoding for binary packets\n            encodePacket(packet, false, encodedPacket => {\n                encodedPackets[i] = encodedPacket;\n                if (++count === length) {\n                    callback(encodedPackets.join(SEPARATOR));\n                }\n            });\n        });\n    };\n    const decodePayload = (encodedPayload, binaryType) => {\n        const encodedPackets = encodedPayload.split(SEPARATOR);\n        const packets = [];\n        for (let i = 0; i < encodedPackets.length; i++) {\n            const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n            packets.push(decodedPacket);\n            if (decodedPacket.type === \"error\") {\n                break;\n            }\n        }\n        return packets;\n    };\n    const protocol$1 = 4;\n\n    class Transport extends Emitter_1 {\n        /**\n         * Transport abstract constructor.\n         *\n         * @param {Object} options.\n         * @api private\n         */\n        constructor(opts) {\n            super();\n            this.writable = false;\n            installTimerFunctions(this, opts);\n            this.opts = opts;\n            this.query = opts.query;\n            this.readyState = \"\";\n            this.socket = opts.socket;\n        }\n        /**\n         * Emits an error.\n         *\n         * @param {String} str\n         * @return {Transport} for chaining\n         * @api protected\n         */\n        onError(msg, desc) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            super.emit(\"error\", err);\n            return this;\n        }\n        /**\n         * Opens the transport.\n         *\n         * @api public\n         */\n        open() {\n            if (\"closed\" === this.readyState || \"\" === this.readyState) {\n                this.readyState = \"opening\";\n                this.doOpen();\n            }\n            return this;\n        }\n        /**\n         * Closes the transport.\n         *\n         * @api public\n         */\n        close() {\n            if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.doClose();\n                this.onClose();\n            }\n            return this;\n        }\n        /**\n         * Sends multiple packets.\n         *\n         * @param {Array} packets\n         * @api public\n         */\n        send(packets) {\n            if (\"open\" === this.readyState) {\n                this.write(packets);\n            }\n        }\n        /**\n         * Called upon open\n         *\n         * @api protected\n         */\n        onOpen() {\n            this.readyState = \"open\";\n            this.writable = true;\n            super.emit(\"open\");\n        }\n        /**\n         * Called with data.\n         *\n         * @param {String} data\n         * @api protected\n         */\n        onData(data) {\n            const packet = decodePacket(data, this.socket.binaryType);\n            this.onPacket(packet);\n        }\n        /**\n         * Called with a decoded packet.\n         *\n         * @api protected\n         */\n        onPacket(packet) {\n            super.emit(\"packet\", packet);\n        }\n        /**\n         * Called upon close.\n         *\n         * @api protected\n         */\n        onClose() {\n            this.readyState = \"closed\";\n            super.emit(\"close\");\n        }\n    }\n\n    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n      , length = 64\n      , map = {}\n      , seed = 0\n      , i = 0\n      , prev;\n\n    /**\n     * Return a string representing the specified number.\n     *\n     * @param {Number} num The number to convert.\n     * @returns {String} The string representation of the number.\n     * @api public\n     */\n    function encode(num) {\n      var encoded = '';\n\n      do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n      } while (num > 0);\n\n      return encoded;\n    }\n\n    /**\n     * Return the integer value specified by the given string.\n     *\n     * @param {String} str The string to convert.\n     * @returns {Number} The integer value represented by the string.\n     * @api public\n     */\n    function decode(str) {\n      var decoded = 0;\n\n      for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n      }\n\n      return decoded;\n    }\n\n    /**\n     * Yeast: A tiny growing id generator.\n     *\n     * @returns {String} A unique id.\n     * @api public\n     */\n    function yeast() {\n      var now = encode(+new Date());\n\n      if (now !== prev) return seed = 0, prev = now;\n      return now +'.'+ encode(seed++);\n    }\n\n    //\n    // Map each character to its index.\n    //\n    for (; i < length; i++) map[alphabet[i]] = i;\n\n    //\n    // Expose the `yeast`, `encode` and `decode` functions.\n    //\n    yeast.encode = encode;\n    yeast.decode = decode;\n    var yeast_1 = yeast;\n\n    var parseqs = {};\n\n    /**\n     * Compiles a querystring\n     * Returns string representation of the object\n     *\n     * @param {Object}\n     * @api private\n     */\n\n    parseqs.encode = function (obj) {\n      var str = '';\n\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          if (str.length) str += '&';\n          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n      }\n\n      return str;\n    };\n\n    /**\n     * Parses a simple querystring into an object\n     *\n     * @param {String} qs\n     * @api private\n     */\n\n    parseqs.decode = function(qs){\n      var qry = {};\n      var pairs = qs.split('&');\n      for (var i = 0, l = pairs.length; i < l; i++) {\n        var pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n      }\n      return qry;\n    };\n\n    class Polling extends Transport {\n        constructor() {\n            super(...arguments);\n            this.polling = false;\n        }\n        /**\n         * Transport name.\n         */\n        get name() {\n            return \"polling\";\n        }\n        /**\n         * Opens the socket (triggers polling). We write a PING message to determine\n         * when the transport is open.\n         *\n         * @api private\n         */\n        doOpen() {\n            this.poll();\n        }\n        /**\n         * Pauses polling.\n         *\n         * @param {Function} callback upon buffers are flushed and transport is paused\n         * @api private\n         */\n        pause(onPause) {\n            this.readyState = \"pausing\";\n            const pause = () => {\n                this.readyState = \"paused\";\n                onPause();\n            };\n            if (this.polling || !this.writable) {\n                let total = 0;\n                if (this.polling) {\n                    total++;\n                    this.once(\"pollComplete\", function () {\n                        --total || pause();\n                    });\n                }\n                if (!this.writable) {\n                    total++;\n                    this.once(\"drain\", function () {\n                        --total || pause();\n                    });\n                }\n            }\n            else {\n                pause();\n            }\n        }\n        /**\n         * Starts polling cycle.\n         *\n         * @api public\n         */\n        poll() {\n            this.polling = true;\n            this.doPoll();\n            this.emit(\"poll\");\n        }\n        /**\n         * Overloads onData to detect payloads.\n         *\n         * @api private\n         */\n        onData(data) {\n            const callback = packet => {\n                // if its the first message we consider the transport open\n                if (\"opening\" === this.readyState && packet.type === \"open\") {\n                    this.onOpen();\n                }\n                // if its a close packet, we close the ongoing requests\n                if (\"close\" === packet.type) {\n                    this.onClose();\n                    return false;\n                }\n                // otherwise bypass onData and handle the message\n                this.onPacket(packet);\n            };\n            // decode payload\n            decodePayload(data, this.socket.binaryType).forEach(callback);\n            // if an event did not trigger closing\n            if (\"closed\" !== this.readyState) {\n                // if we got data we're not polling\n                this.polling = false;\n                this.emit(\"pollComplete\");\n                if (\"open\" === this.readyState) {\n                    this.poll();\n                }\n            }\n        }\n        /**\n         * For polling, send a close packet.\n         *\n         * @api private\n         */\n        doClose() {\n            const close = () => {\n                this.write([{ type: \"close\" }]);\n            };\n            if (\"open\" === this.readyState) {\n                close();\n            }\n            else {\n                // in case we're trying to close while\n                // handshaking is in progress (GH-164)\n                this.once(\"open\", close);\n            }\n        }\n        /**\n         * Writes a packets payload.\n         *\n         * @param {Array} data packets\n         * @param {Function} drain callback\n         * @api private\n         */\n        write(packets) {\n            this.writable = false;\n            encodePayload(packets, data => {\n                this.doWrite(data, () => {\n                    this.writable = true;\n                    this.emit(\"drain\");\n                });\n            });\n        }\n        /**\n         * Generates uri for connection.\n         *\n         * @api private\n         */\n        uri() {\n            let query = this.query || {};\n            const schema = this.opts.secure ? \"https\" : \"http\";\n            let port = \"\";\n            // cache busting is forced\n            if (false !== this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast_1();\n            }\n            if (!this.supportsBinary && !query.sid) {\n                query.b64 = 1;\n            }\n            // avoid port if default for schema\n            if (this.opts.port &&\n                ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                    (\"http\" === schema && Number(this.opts.port) !== 80))) {\n                port = \":\" + this.opts.port;\n            }\n            const encodedQuery = parseqs.encode(query);\n            const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n            return (schema +\n                \"://\" +\n                (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n                port +\n                this.opts.path +\n                (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n        }\n    }\n\n    /* global attachEvent */\n    /**\n     * Empty function\n     */\n    function empty() { }\n    const hasXHR2 = (function () {\n        const xhr = new XMLHttpRequest$1({\n            xdomain: false\n        });\n        return null != xhr.responseType;\n    })();\n    class XHR extends Polling {\n        /**\n         * XHR Polling constructor.\n         *\n         * @param {Object} opts\n         * @api public\n         */\n        constructor(opts) {\n            super(opts);\n            if (typeof location !== \"undefined\") {\n                const isSSL = \"https:\" === location.protocol;\n                let port = location.port;\n                // some user agents have empty `location.port`\n                if (!port) {\n                    port = isSSL ? \"443\" : \"80\";\n                }\n                this.xd =\n                    (typeof location !== \"undefined\" &&\n                        opts.hostname !== location.hostname) ||\n                        port !== opts.port;\n                this.xs = opts.secure !== isSSL;\n            }\n            /**\n             * XHR supports binary\n             */\n            const forceBase64 = opts && opts.forceBase64;\n            this.supportsBinary = hasXHR2 && !forceBase64;\n        }\n        /**\n         * Creates a request.\n         *\n         * @param {String} method\n         * @api private\n         */\n        request(opts = {}) {\n            Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n            return new Request(this.uri(), opts);\n        }\n        /**\n         * Sends data.\n         *\n         * @param {String} data to send.\n         * @param {Function} called upon flush.\n         * @api private\n         */\n        doWrite(data, fn) {\n            const req = this.request({\n                method: \"POST\",\n                data: data\n            });\n            req.on(\"success\", fn);\n            req.on(\"error\", err => {\n                this.onError(\"xhr post error\", err);\n            });\n        }\n        /**\n         * Starts a poll cycle.\n         *\n         * @api private\n         */\n        doPoll() {\n            const req = this.request();\n            req.on(\"data\", this.onData.bind(this));\n            req.on(\"error\", err => {\n                this.onError(\"xhr poll error\", err);\n            });\n            this.pollXhr = req;\n        }\n    }\n    class Request extends Emitter_1 {\n        /**\n         * Request constructor\n         *\n         * @param {Object} options\n         * @api public\n         */\n        constructor(uri, opts) {\n            super();\n            installTimerFunctions(this, opts);\n            this.opts = opts;\n            this.method = opts.method || \"GET\";\n            this.uri = uri;\n            this.async = false !== opts.async;\n            this.data = undefined !== opts.data ? opts.data : null;\n            this.create();\n        }\n        /**\n         * Creates the XHR object and sends the request.\n         *\n         * @api private\n         */\n        create() {\n            const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n            opts.xdomain = !!this.opts.xd;\n            opts.xscheme = !!this.opts.xs;\n            const xhr = (this.xhr = new XMLHttpRequest$1(opts));\n            try {\n                xhr.open(this.method, this.uri, this.async);\n                try {\n                    if (this.opts.extraHeaders) {\n                        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                        for (let i in this.opts.extraHeaders) {\n                            if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                            }\n                        }\n                    }\n                }\n                catch (e) { }\n                if (\"POST\" === this.method) {\n                    try {\n                        xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                    }\n                    catch (e) { }\n                }\n                try {\n                    xhr.setRequestHeader(\"Accept\", \"*/*\");\n                }\n                catch (e) { }\n                // ie6 check\n                if (\"withCredentials\" in xhr) {\n                    xhr.withCredentials = this.opts.withCredentials;\n                }\n                if (this.opts.requestTimeout) {\n                    xhr.timeout = this.opts.requestTimeout;\n                }\n                xhr.onreadystatechange = () => {\n                    if (4 !== xhr.readyState)\n                        return;\n                    if (200 === xhr.status || 1223 === xhr.status) {\n                        this.onLoad();\n                    }\n                    else {\n                        // make sure the `error` event handler that's user-set\n                        // does not throw in the same tick and gets caught here\n                        this.setTimeoutFn(() => {\n                            this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                        }, 0);\n                    }\n                };\n                xhr.send(this.data);\n            }\n            catch (e) {\n                // Need to defer since .create() is called directly from the constructor\n                // and thus the 'error' event can only be only bound *after* this exception\n                // occurs.  Therefore, also, we cannot throw here at all.\n                this.setTimeoutFn(() => {\n                    this.onError(e);\n                }, 0);\n                return;\n            }\n            if (typeof document !== \"undefined\") {\n                this.index = Request.requestsCount++;\n                Request.requests[this.index] = this;\n            }\n        }\n        /**\n         * Called upon successful response.\n         *\n         * @api private\n         */\n        onSuccess() {\n            this.emit(\"success\");\n            this.cleanup();\n        }\n        /**\n         * Called if we have data.\n         *\n         * @api private\n         */\n        onData(data) {\n            this.emit(\"data\", data);\n            this.onSuccess();\n        }\n        /**\n         * Called upon error.\n         *\n         * @api private\n         */\n        onError(err) {\n            this.emit(\"error\", err);\n            this.cleanup(true);\n        }\n        /**\n         * Cleans up house.\n         *\n         * @api private\n         */\n        cleanup(fromError) {\n            if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n                return;\n            }\n            this.xhr.onreadystatechange = empty;\n            if (fromError) {\n                try {\n                    this.xhr.abort();\n                }\n                catch (e) { }\n            }\n            if (typeof document !== \"undefined\") {\n                delete Request.requests[this.index];\n            }\n            this.xhr = null;\n        }\n        /**\n         * Called upon load.\n         *\n         * @api private\n         */\n        onLoad() {\n            const data = this.xhr.responseText;\n            if (data !== null) {\n                this.onData(data);\n            }\n        }\n        /**\n         * Aborts the request.\n         *\n         * @api public\n         */\n        abort() {\n            this.cleanup();\n        }\n    }\n    Request.requestsCount = 0;\n    Request.requests = {};\n    /**\n     * Aborts pending requests when unloading the window. This is needed to prevent\n     * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n     * emitted.\n     */\n    if (typeof document !== \"undefined\") {\n        // @ts-ignore\n        if (typeof attachEvent === \"function\") {\n            // @ts-ignore\n            attachEvent(\"onunload\", unloadHandler);\n        }\n        else if (typeof addEventListener === \"function\") {\n            const terminationEvent = \"onpagehide\" in globalThis$1 ? \"pagehide\" : \"unload\";\n            addEventListener(terminationEvent, unloadHandler, false);\n        }\n    }\n    function unloadHandler() {\n        for (let i in Request.requests) {\n            if (Request.requests.hasOwnProperty(i)) {\n                Request.requests[i].abort();\n            }\n        }\n    }\n\n    const nextTick = (() => {\n        const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n        if (isPromiseAvailable) {\n            return cb => Promise.resolve().then(cb);\n        }\n        else {\n            return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n        }\n    })();\n    const WebSocket = globalThis$1.WebSocket || globalThis$1.MozWebSocket;\n    const usingBrowserWebSocket = true;\n    const defaultBinaryType = \"arraybuffer\";\n\n    // detect ReactNative environment\n    const isReactNative = typeof navigator !== \"undefined\" &&\n        typeof navigator.product === \"string\" &&\n        navigator.product.toLowerCase() === \"reactnative\";\n    class WS extends Transport {\n        /**\n         * WebSocket transport constructor.\n         *\n         * @api {Object} connection options\n         * @api public\n         */\n        constructor(opts) {\n            super(opts);\n            this.supportsBinary = !opts.forceBase64;\n        }\n        /**\n         * Transport name.\n         *\n         * @api public\n         */\n        get name() {\n            return \"websocket\";\n        }\n        /**\n         * Opens socket.\n         *\n         * @api private\n         */\n        doOpen() {\n            if (!this.check()) {\n                // let probe timeout\n                return;\n            }\n            const uri = this.uri();\n            const protocols = this.opts.protocols;\n            // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n            const opts = isReactNative\n                ? {}\n                : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n            if (this.opts.extraHeaders) {\n                opts.headers = this.opts.extraHeaders;\n            }\n            try {\n                this.ws =\n                    usingBrowserWebSocket && !isReactNative\n                        ? protocols\n                            ? new WebSocket(uri, protocols)\n                            : new WebSocket(uri)\n                        : new WebSocket(uri, protocols, opts);\n            }\n            catch (err) {\n                return this.emit(\"error\", err);\n            }\n            this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n            this.addEventListeners();\n        }\n        /**\n         * Adds event listeners to the socket\n         *\n         * @api private\n         */\n        addEventListeners() {\n            this.ws.onopen = () => {\n                if (this.opts.autoUnref) {\n                    this.ws._socket.unref();\n                }\n                this.onOpen();\n            };\n            this.ws.onclose = this.onClose.bind(this);\n            this.ws.onmessage = ev => this.onData(ev.data);\n            this.ws.onerror = e => this.onError(\"websocket error\", e);\n        }\n        /**\n         * Writes data to socket.\n         *\n         * @param {Array} array of packets.\n         * @api private\n         */\n        write(packets) {\n            this.writable = false;\n            // encodePacket efficient as it uses WS framing\n            // no need for encodePayload\n            for (let i = 0; i < packets.length; i++) {\n                const packet = packets[i];\n                const lastPacket = i === packets.length - 1;\n                encodePacket(packet, this.supportsBinary, data => {\n                    // always create a new object (GH-437)\n                    const opts = {};\n                    // Sometimes the websocket has already been closed but the browser didn't\n                    // have a chance of informing us about it yet, in that case send will\n                    // throw an error\n                    try {\n                        if (usingBrowserWebSocket) {\n                            // TypeError is thrown when passing the second argument on Safari\n                            this.ws.send(data);\n                        }\n                    }\n                    catch (e) {\n                    }\n                    if (lastPacket) {\n                        // fake drain\n                        // defer to next tick to allow Socket to clear writeBuffer\n                        nextTick(() => {\n                            this.writable = true;\n                            this.emit(\"drain\");\n                        }, this.setTimeoutFn);\n                    }\n                });\n            }\n        }\n        /**\n         * Closes socket.\n         *\n         * @api private\n         */\n        doClose() {\n            if (typeof this.ws !== \"undefined\") {\n                this.ws.close();\n                this.ws = null;\n            }\n        }\n        /**\n         * Generates uri for connection.\n         *\n         * @api private\n         */\n        uri() {\n            let query = this.query || {};\n            const schema = this.opts.secure ? \"wss\" : \"ws\";\n            let port = \"\";\n            // avoid port if default for schema\n            if (this.opts.port &&\n                ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                    (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n                port = \":\" + this.opts.port;\n            }\n            // append timestamp to URI\n            if (this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = yeast_1();\n            }\n            // communicate binary support capabilities\n            if (!this.supportsBinary) {\n                query.b64 = 1;\n            }\n            const encodedQuery = parseqs.encode(query);\n            const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n            return (schema +\n                \"://\" +\n                (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n                port +\n                this.opts.path +\n                (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n        }\n        /**\n         * Feature detection for WebSocket.\n         *\n         * @return {Boolean} whether this transport is available.\n         * @api public\n         */\n        check() {\n            return (!!WebSocket &&\n                !(\"__initialize\" in WebSocket && this.name === WS.prototype.name));\n        }\n    }\n\n    const transports = {\n        websocket: WS,\n        polling: XHR\n    };\n\n    class Socket$1 extends Emitter_1 {\n        /**\n         * Socket constructor.\n         *\n         * @param {String|Object} uri or options\n         * @param {Object} opts - options\n         * @api public\n         */\n        constructor(uri, opts = {}) {\n            super();\n            if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = null;\n            }\n            if (uri) {\n                uri = parseuri(uri);\n                opts.hostname = uri.host;\n                opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n                opts.port = uri.port;\n                if (uri.query)\n                    opts.query = uri.query;\n            }\n            else if (opts.host) {\n                opts.hostname = parseuri(opts.host).host;\n            }\n            installTimerFunctions(this, opts);\n            this.secure =\n                null != opts.secure\n                    ? opts.secure\n                    : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n            if (opts.hostname && !opts.port) {\n                // if no port is specified manually, use the protocol default\n                opts.port = this.secure ? \"443\" : \"80\";\n            }\n            this.hostname =\n                opts.hostname ||\n                    (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n            this.port =\n                opts.port ||\n                    (typeof location !== \"undefined\" && location.port\n                        ? location.port\n                        : this.secure\n                            ? \"443\"\n                            : \"80\");\n            this.transports = opts.transports || [\"polling\", \"websocket\"];\n            this.readyState = \"\";\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n            this.opts = Object.assign({\n                path: \"/engine.io\",\n                agent: false,\n                withCredentials: false,\n                upgrade: true,\n                timestampParam: \"t\",\n                rememberUpgrade: false,\n                rejectUnauthorized: true,\n                perMessageDeflate: {\n                    threshold: 1024\n                },\n                transportOptions: {},\n                closeOnBeforeunload: true\n            }, opts);\n            this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n            if (typeof this.opts.query === \"string\") {\n                this.opts.query = parseqs.decode(this.opts.query);\n            }\n            // set on handshake\n            this.id = null;\n            this.upgrades = null;\n            this.pingInterval = null;\n            this.pingTimeout = null;\n            // set on heartbeat\n            this.pingTimeoutTimer = null;\n            if (typeof addEventListener === \"function\") {\n                if (this.opts.closeOnBeforeunload) {\n                    // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                    // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                    // closed/reloaded)\n                    addEventListener(\"beforeunload\", () => {\n                        if (this.transport) {\n                            // silently close the transport\n                            this.transport.removeAllListeners();\n                            this.transport.close();\n                        }\n                    }, false);\n                }\n                if (this.hostname !== \"localhost\") {\n                    this.offlineEventListener = () => {\n                        this.onClose(\"transport close\");\n                    };\n                    addEventListener(\"offline\", this.offlineEventListener, false);\n                }\n            }\n            this.open();\n        }\n        /**\n         * Creates transport of the given type.\n         *\n         * @param {String} transport name\n         * @return {Transport}\n         * @api private\n         */\n        createTransport(name) {\n            const query = clone(this.opts.query);\n            // append engine.io protocol identifier\n            query.EIO = protocol$1;\n            // transport name\n            query.transport = name;\n            // session id if we already have one\n            if (this.id)\n                query.sid = this.id;\n            const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n                query,\n                socket: this,\n                hostname: this.hostname,\n                secure: this.secure,\n                port: this.port\n            });\n            return new transports[name](opts);\n        }\n        /**\n         * Initializes transport to use and starts probe.\n         *\n         * @api private\n         */\n        open() {\n            let transport;\n            if (this.opts.rememberUpgrade &&\n                Socket$1.priorWebsocketSuccess &&\n                this.transports.indexOf(\"websocket\") !== -1) {\n                transport = \"websocket\";\n            }\n            else if (0 === this.transports.length) {\n                // Emit error on next tick so it can be listened to\n                this.setTimeoutFn(() => {\n                    this.emitReserved(\"error\", \"No transports available\");\n                }, 0);\n                return;\n            }\n            else {\n                transport = this.transports[0];\n            }\n            this.readyState = \"opening\";\n            // Retry with the next transport if the transport is disabled (jsonp: false)\n            try {\n                transport = this.createTransport(transport);\n            }\n            catch (e) {\n                this.transports.shift();\n                this.open();\n                return;\n            }\n            transport.open();\n            this.setTransport(transport);\n        }\n        /**\n         * Sets the current transport. Disables the existing one (if any).\n         *\n         * @api private\n         */\n        setTransport(transport) {\n            if (this.transport) {\n                this.transport.removeAllListeners();\n            }\n            // set up transport\n            this.transport = transport;\n            // set up transport listeners\n            transport\n                .on(\"drain\", this.onDrain.bind(this))\n                .on(\"packet\", this.onPacket.bind(this))\n                .on(\"error\", this.onError.bind(this))\n                .on(\"close\", () => {\n                this.onClose(\"transport close\");\n            });\n        }\n        /**\n         * Probes a transport.\n         *\n         * @param {String} transport name\n         * @api private\n         */\n        probe(name) {\n            let transport = this.createTransport(name);\n            let failed = false;\n            Socket$1.priorWebsocketSuccess = false;\n            const onTransportOpen = () => {\n                if (failed)\n                    return;\n                transport.send([{ type: \"ping\", data: \"probe\" }]);\n                transport.once(\"packet\", msg => {\n                    if (failed)\n                        return;\n                    if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                        this.upgrading = true;\n                        this.emitReserved(\"upgrading\", transport);\n                        if (!transport)\n                            return;\n                        Socket$1.priorWebsocketSuccess = \"websocket\" === transport.name;\n                        this.transport.pause(() => {\n                            if (failed)\n                                return;\n                            if (\"closed\" === this.readyState)\n                                return;\n                            cleanup();\n                            this.setTransport(transport);\n                            transport.send([{ type: \"upgrade\" }]);\n                            this.emitReserved(\"upgrade\", transport);\n                            transport = null;\n                            this.upgrading = false;\n                            this.flush();\n                        });\n                    }\n                    else {\n                        const err = new Error(\"probe error\");\n                        // @ts-ignore\n                        err.transport = transport.name;\n                        this.emitReserved(\"upgradeError\", err);\n                    }\n                });\n            };\n            function freezeTransport() {\n                if (failed)\n                    return;\n                // Any callback called by transport should be ignored since now\n                failed = true;\n                cleanup();\n                transport.close();\n                transport = null;\n            }\n            // Handle any error that happens while probing\n            const onerror = err => {\n                const error = new Error(\"probe error: \" + err);\n                // @ts-ignore\n                error.transport = transport.name;\n                freezeTransport();\n                this.emitReserved(\"upgradeError\", error);\n            };\n            function onTransportClose() {\n                onerror(\"transport closed\");\n            }\n            // When the socket is closed while we're probing\n            function onclose() {\n                onerror(\"socket closed\");\n            }\n            // When the socket is upgraded while we're probing\n            function onupgrade(to) {\n                if (transport && to.name !== transport.name) {\n                    freezeTransport();\n                }\n            }\n            // Remove all listeners on the transport and on self\n            const cleanup = () => {\n                transport.removeListener(\"open\", onTransportOpen);\n                transport.removeListener(\"error\", onerror);\n                transport.removeListener(\"close\", onTransportClose);\n                this.off(\"close\", onclose);\n                this.off(\"upgrading\", onupgrade);\n            };\n            transport.once(\"open\", onTransportOpen);\n            transport.once(\"error\", onerror);\n            transport.once(\"close\", onTransportClose);\n            this.once(\"close\", onclose);\n            this.once(\"upgrading\", onupgrade);\n            transport.open();\n        }\n        /**\n         * Called when connection is deemed open.\n         *\n         * @api private\n         */\n        onOpen() {\n            this.readyState = \"open\";\n            Socket$1.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n            this.emitReserved(\"open\");\n            this.flush();\n            // we check for `readyState` in case an `open`\n            // listener already closed the socket\n            if (\"open\" === this.readyState &&\n                this.opts.upgrade &&\n                this.transport.pause) {\n                let i = 0;\n                const l = this.upgrades.length;\n                for (; i < l; i++) {\n                    this.probe(this.upgrades[i]);\n                }\n            }\n        }\n        /**\n         * Handles a packet.\n         *\n         * @api private\n         */\n        onPacket(packet) {\n            if (\"opening\" === this.readyState ||\n                \"open\" === this.readyState ||\n                \"closing\" === this.readyState) {\n                this.emitReserved(\"packet\", packet);\n                // Socket is live - any packet counts\n                this.emitReserved(\"heartbeat\");\n                switch (packet.type) {\n                    case \"open\":\n                        this.onHandshake(JSON.parse(packet.data));\n                        break;\n                    case \"ping\":\n                        this.resetPingTimeout();\n                        this.sendPacket(\"pong\");\n                        this.emitReserved(\"ping\");\n                        this.emitReserved(\"pong\");\n                        break;\n                    case \"error\":\n                        const err = new Error(\"server error\");\n                        // @ts-ignore\n                        err.code = packet.data;\n                        this.onError(err);\n                        break;\n                    case \"message\":\n                        this.emitReserved(\"data\", packet.data);\n                        this.emitReserved(\"message\", packet.data);\n                        break;\n                }\n            }\n        }\n        /**\n         * Called upon handshake completion.\n         *\n         * @param {Object} data - handshake obj\n         * @api private\n         */\n        onHandshake(data) {\n            this.emitReserved(\"handshake\", data);\n            this.id = data.sid;\n            this.transport.query.sid = data.sid;\n            this.upgrades = this.filterUpgrades(data.upgrades);\n            this.pingInterval = data.pingInterval;\n            this.pingTimeout = data.pingTimeout;\n            this.onOpen();\n            // In case open handler closes socket\n            if (\"closed\" === this.readyState)\n                return;\n            this.resetPingTimeout();\n        }\n        /**\n         * Sets and resets ping timeout timer based on server pings.\n         *\n         * @api private\n         */\n        resetPingTimeout() {\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            this.pingTimeoutTimer = this.setTimeoutFn(() => {\n                this.onClose(\"ping timeout\");\n            }, this.pingInterval + this.pingTimeout);\n            if (this.opts.autoUnref) {\n                this.pingTimeoutTimer.unref();\n            }\n        }\n        /**\n         * Called on `drain` event\n         *\n         * @api private\n         */\n        onDrain() {\n            this.writeBuffer.splice(0, this.prevBufferLen);\n            // setting prevBufferLen = 0 is very important\n            // for example, when upgrading, upgrade packet is sent over,\n            // and a nonzero prevBufferLen could cause problems on `drain`\n            this.prevBufferLen = 0;\n            if (0 === this.writeBuffer.length) {\n                this.emitReserved(\"drain\");\n            }\n            else {\n                this.flush();\n            }\n        }\n        /**\n         * Flush write buffers.\n         *\n         * @api private\n         */\n        flush() {\n            if (\"closed\" !== this.readyState &&\n                this.transport.writable &&\n                !this.upgrading &&\n                this.writeBuffer.length) {\n                this.transport.send(this.writeBuffer);\n                // keep track of current length of writeBuffer\n                // splice writeBuffer and callbackBuffer on `drain`\n                this.prevBufferLen = this.writeBuffer.length;\n                this.emitReserved(\"flush\");\n            }\n        }\n        /**\n         * Sends a message.\n         *\n         * @param {String} message.\n         * @param {Function} callback function.\n         * @param {Object} options.\n         * @return {Socket} for chaining.\n         * @api public\n         */\n        write(msg, options, fn) {\n            this.sendPacket(\"message\", msg, options, fn);\n            return this;\n        }\n        send(msg, options, fn) {\n            this.sendPacket(\"message\", msg, options, fn);\n            return this;\n        }\n        /**\n         * Sends a packet.\n         *\n         * @param {String} packet type.\n         * @param {String} data.\n         * @param {Object} options.\n         * @param {Function} callback function.\n         * @api private\n         */\n        sendPacket(type, data, options, fn) {\n            if (\"function\" === typeof data) {\n                fn = data;\n                data = undefined;\n            }\n            if (\"function\" === typeof options) {\n                fn = options;\n                options = null;\n            }\n            if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n                return;\n            }\n            options = options || {};\n            options.compress = false !== options.compress;\n            const packet = {\n                type: type,\n                data: data,\n                options: options\n            };\n            this.emitReserved(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            if (fn)\n                this.once(\"flush\", fn);\n            this.flush();\n        }\n        /**\n         * Closes the connection.\n         *\n         * @api public\n         */\n        close() {\n            const close = () => {\n                this.onClose(\"forced close\");\n                this.transport.close();\n            };\n            const cleanupAndClose = () => {\n                this.off(\"upgrade\", cleanupAndClose);\n                this.off(\"upgradeError\", cleanupAndClose);\n                close();\n            };\n            const waitForUpgrade = () => {\n                // wait for upgrade to finish since we can't send packets while pausing a transport\n                this.once(\"upgrade\", cleanupAndClose);\n                this.once(\"upgradeError\", cleanupAndClose);\n            };\n            if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.readyState = \"closing\";\n                if (this.writeBuffer.length) {\n                    this.once(\"drain\", () => {\n                        if (this.upgrading) {\n                            waitForUpgrade();\n                        }\n                        else {\n                            close();\n                        }\n                    });\n                }\n                else if (this.upgrading) {\n                    waitForUpgrade();\n                }\n                else {\n                    close();\n                }\n            }\n            return this;\n        }\n        /**\n         * Called upon transport error\n         *\n         * @api private\n         */\n        onError(err) {\n            Socket$1.priorWebsocketSuccess = false;\n            this.emitReserved(\"error\", err);\n            this.onClose(\"transport error\", err);\n        }\n        /**\n         * Called upon transport close.\n         *\n         * @api private\n         */\n        onClose(reason, desc) {\n            if (\"opening\" === this.readyState ||\n                \"open\" === this.readyState ||\n                \"closing\" === this.readyState) {\n                // clear timers\n                this.clearTimeoutFn(this.pingTimeoutTimer);\n                // stop event from firing again for transport\n                this.transport.removeAllListeners(\"close\");\n                // ensure transport won't stay open\n                this.transport.close();\n                // ignore further transport communication\n                this.transport.removeAllListeners();\n                if (typeof removeEventListener === \"function\") {\n                    removeEventListener(\"offline\", this.offlineEventListener, false);\n                }\n                // set ready state\n                this.readyState = \"closed\";\n                // clear session id\n                this.id = null;\n                // emit close event\n                this.emitReserved(\"close\", reason, desc);\n                // clean buffers after, so users can still\n                // grab the buffers on `close` event\n                this.writeBuffer = [];\n                this.prevBufferLen = 0;\n            }\n        }\n        /**\n         * Filters upgrades, returning only those matching client transports.\n         *\n         * @param {Array} server upgrades\n         * @api private\n         *\n         */\n        filterUpgrades(upgrades) {\n            const filteredUpgrades = [];\n            let i = 0;\n            const j = upgrades.length;\n            for (; i < j; i++) {\n                if (~this.transports.indexOf(upgrades[i]))\n                    filteredUpgrades.push(upgrades[i]);\n            }\n            return filteredUpgrades;\n        }\n    }\n    Socket$1.protocol = protocol$1;\n    function clone(obj) {\n        const o = {};\n        for (let i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                o[i] = obj[i];\n            }\n        }\n        return o;\n    }\n\n    Socket$1.protocol;\n\n    const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n    const isView = (obj) => {\n        return typeof ArrayBuffer.isView === \"function\"\n            ? ArrayBuffer.isView(obj)\n            : obj.buffer instanceof ArrayBuffer;\n    };\n    const toString = Object.prototype.toString;\n    const withNativeBlob = typeof Blob === \"function\" ||\n        (typeof Blob !== \"undefined\" &&\n            toString.call(Blob) === \"[object BlobConstructor]\");\n    const withNativeFile = typeof File === \"function\" ||\n        (typeof File !== \"undefined\" &&\n            toString.call(File) === \"[object FileConstructor]\");\n    /**\n     * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n     *\n     * @private\n     */\n    function isBinary(obj) {\n        return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n            (withNativeBlob && obj instanceof Blob) ||\n            (withNativeFile && obj instanceof File));\n    }\n    function hasBinary(obj, toJSON) {\n        if (!obj || typeof obj !== \"object\") {\n            return false;\n        }\n        if (Array.isArray(obj)) {\n            for (let i = 0, l = obj.length; i < l; i++) {\n                if (hasBinary(obj[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (isBinary(obj)) {\n            return true;\n        }\n        if (obj.toJSON &&\n            typeof obj.toJSON === \"function\" &&\n            arguments.length === 1) {\n            return hasBinary(obj.toJSON(), true);\n        }\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n     *\n     * @param {Object} packet - socket.io event packet\n     * @return {Object} with deconstructed packet and list of buffers\n     * @public\n     */\n    function deconstructPacket(packet) {\n        const buffers = [];\n        const packetData = packet.data;\n        const pack = packet;\n        pack.data = _deconstructPacket(packetData, buffers);\n        pack.attachments = buffers.length; // number of binary 'attachments'\n        return { packet: pack, buffers: buffers };\n    }\n    function _deconstructPacket(data, buffers) {\n        if (!data)\n            return data;\n        if (isBinary(data)) {\n            const placeholder = { _placeholder: true, num: buffers.length };\n            buffers.push(data);\n            return placeholder;\n        }\n        else if (Array.isArray(data)) {\n            const newData = new Array(data.length);\n            for (let i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i], buffers);\n            }\n            return newData;\n        }\n        else if (typeof data === \"object\" && !(data instanceof Date)) {\n            const newData = {};\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    newData[key] = _deconstructPacket(data[key], buffers);\n                }\n            }\n            return newData;\n        }\n        return data;\n    }\n    /**\n     * Reconstructs a binary packet from its placeholder packet and buffers\n     *\n     * @param {Object} packet - event packet with placeholders\n     * @param {Array} buffers - binary buffers to put in placeholder positions\n     * @return {Object} reconstructed packet\n     * @public\n     */\n    function reconstructPacket(packet, buffers) {\n        packet.data = _reconstructPacket(packet.data, buffers);\n        packet.attachments = undefined; // no longer useful\n        return packet;\n    }\n    function _reconstructPacket(data, buffers) {\n        if (!data)\n            return data;\n        if (data && data._placeholder) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else if (Array.isArray(data)) {\n            for (let i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i], buffers);\n            }\n        }\n        else if (typeof data === \"object\") {\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    data[key] = _reconstructPacket(data[key], buffers);\n                }\n            }\n        }\n        return data;\n    }\n\n    /**\n     * Protocol version.\n     *\n     * @public\n     */\n    const protocol = 5;\n    var PacketType;\n    (function (PacketType) {\n        PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n        PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n        PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n        PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n        PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n        PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n        PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n    })(PacketType || (PacketType = {}));\n    /**\n     * A socket.io Encoder instance\n     */\n    class Encoder {\n        /**\n         * Encode a packet as a single string if non-binary, or as a\n         * buffer sequence, depending on packet type.\n         *\n         * @param {Object} obj - packet object\n         */\n        encode(obj) {\n            if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                if (hasBinary(obj)) {\n                    obj.type =\n                        obj.type === PacketType.EVENT\n                            ? PacketType.BINARY_EVENT\n                            : PacketType.BINARY_ACK;\n                    return this.encodeAsBinary(obj);\n                }\n            }\n            return [this.encodeAsString(obj)];\n        }\n        /**\n         * Encode packet as string.\n         */\n        encodeAsString(obj) {\n            // first is type\n            let str = \"\" + obj.type;\n            // attachments if we have them\n            if (obj.type === PacketType.BINARY_EVENT ||\n                obj.type === PacketType.BINARY_ACK) {\n                str += obj.attachments + \"-\";\n            }\n            // if we have a namespace other than `/`\n            // we append it followed by a comma `,`\n            if (obj.nsp && \"/\" !== obj.nsp) {\n                str += obj.nsp + \",\";\n            }\n            // immediately followed by the id\n            if (null != obj.id) {\n                str += obj.id;\n            }\n            // json data\n            if (null != obj.data) {\n                str += JSON.stringify(obj.data);\n            }\n            return str;\n        }\n        /**\n         * Encode packet as 'buffer sequence' by removing blobs, and\n         * deconstructing packet into object with placeholders and\n         * a list of buffers.\n         */\n        encodeAsBinary(obj) {\n            const deconstruction = deconstructPacket(obj);\n            const pack = this.encodeAsString(deconstruction.packet);\n            const buffers = deconstruction.buffers;\n            buffers.unshift(pack); // add packet info to beginning of data list\n            return buffers; // write all the buffers\n        }\n    }\n    /**\n     * A socket.io Decoder instance\n     *\n     * @return {Object} decoder\n     */\n    class Decoder extends Emitter_1 {\n        constructor() {\n            super();\n        }\n        /**\n         * Decodes an encoded packet string into packet JSON.\n         *\n         * @param {String} obj - encoded packet\n         */\n        add(obj) {\n            let packet;\n            if (typeof obj === \"string\") {\n                packet = this.decodeString(obj);\n                if (packet.type === PacketType.BINARY_EVENT ||\n                    packet.type === PacketType.BINARY_ACK) {\n                    // binary packet's json\n                    this.reconstructor = new BinaryReconstructor(packet);\n                    // no attachments, labeled binary but no binary data to follow\n                    if (packet.attachments === 0) {\n                        super.emitReserved(\"decoded\", packet);\n                    }\n                }\n                else {\n                    // non-binary full packet\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else if (isBinary(obj) || obj.base64) {\n                // raw binary data\n                if (!this.reconstructor) {\n                    throw new Error(\"got binary data when not reconstructing a packet\");\n                }\n                else {\n                    packet = this.reconstructor.takeBinaryData(obj);\n                    if (packet) {\n                        // received final buffer\n                        this.reconstructor = null;\n                        super.emitReserved(\"decoded\", packet);\n                    }\n                }\n            }\n            else {\n                throw new Error(\"Unknown type: \" + obj);\n            }\n        }\n        /**\n         * Decode a packet String (JSON data)\n         *\n         * @param {String} str\n         * @return {Object} packet\n         */\n        decodeString(str) {\n            let i = 0;\n            // look up type\n            const p = {\n                type: Number(str.charAt(0)),\n            };\n            if (PacketType[p.type] === undefined) {\n                throw new Error(\"unknown packet type \" + p.type);\n            }\n            // look up attachments if type binary\n            if (p.type === PacketType.BINARY_EVENT ||\n                p.type === PacketType.BINARY_ACK) {\n                const start = i + 1;\n                while (str.charAt(++i) !== \"-\" && i != str.length) { }\n                const buf = str.substring(start, i);\n                if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                    throw new Error(\"Illegal attachments\");\n                }\n                p.attachments = Number(buf);\n            }\n            // look up namespace (if any)\n            if (\"/\" === str.charAt(i + 1)) {\n                const start = i + 1;\n                while (++i) {\n                    const c = str.charAt(i);\n                    if (\",\" === c)\n                        break;\n                    if (i === str.length)\n                        break;\n                }\n                p.nsp = str.substring(start, i);\n            }\n            else {\n                p.nsp = \"/\";\n            }\n            // look up id\n            const next = str.charAt(i + 1);\n            if (\"\" !== next && Number(next) == next) {\n                const start = i + 1;\n                while (++i) {\n                    const c = str.charAt(i);\n                    if (null == c || Number(c) != c) {\n                        --i;\n                        break;\n                    }\n                    if (i === str.length)\n                        break;\n                }\n                p.id = Number(str.substring(start, i + 1));\n            }\n            // look up json data\n            if (str.charAt(++i)) {\n                const payload = tryParse(str.substr(i));\n                if (Decoder.isPayloadValid(p.type, payload)) {\n                    p.data = payload;\n                }\n                else {\n                    throw new Error(\"invalid payload\");\n                }\n            }\n            return p;\n        }\n        static isPayloadValid(type, payload) {\n            switch (type) {\n                case PacketType.CONNECT:\n                    return typeof payload === \"object\";\n                case PacketType.DISCONNECT:\n                    return payload === undefined;\n                case PacketType.CONNECT_ERROR:\n                    return typeof payload === \"string\" || typeof payload === \"object\";\n                case PacketType.EVENT:\n                case PacketType.BINARY_EVENT:\n                    return Array.isArray(payload) && payload.length > 0;\n                case PacketType.ACK:\n                case PacketType.BINARY_ACK:\n                    return Array.isArray(payload);\n            }\n        }\n        /**\n         * Deallocates a parser's resources\n         */\n        destroy() {\n            if (this.reconstructor) {\n                this.reconstructor.finishedReconstruction();\n            }\n        }\n    }\n    function tryParse(str) {\n        try {\n            return JSON.parse(str);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * A manager of a binary event's 'buffer sequence'. Should\n     * be constructed whenever a packet of type BINARY_EVENT is\n     * decoded.\n     *\n     * @param {Object} packet\n     * @return {BinaryReconstructor} initialized reconstructor\n     */\n    class BinaryReconstructor {\n        constructor(packet) {\n            this.packet = packet;\n            this.buffers = [];\n            this.reconPack = packet;\n        }\n        /**\n         * Method to be called when binary data received from connection\n         * after a BINARY_EVENT packet.\n         *\n         * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n         * @return {null | Object} returns null if more binary data is expected or\n         *   a reconstructed packet object if all buffers have been received.\n         */\n        takeBinaryData(binData) {\n            this.buffers.push(binData);\n            if (this.buffers.length === this.reconPack.attachments) {\n                // done with buffer list\n                const packet = reconstructPacket(this.reconPack, this.buffers);\n                this.finishedReconstruction();\n                return packet;\n            }\n            return null;\n        }\n        /**\n         * Cleans up binary packet reconstruction variables.\n         */\n        finishedReconstruction() {\n            this.reconPack = null;\n            this.buffers = [];\n        }\n    }\n\n    var parser = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        protocol: protocol,\n        get PacketType () { return PacketType; },\n        Encoder: Encoder,\n        Decoder: Decoder\n    });\n\n    function on(obj, ev, fn) {\n        obj.on(ev, fn);\n        return function subDestroy() {\n            obj.off(ev, fn);\n        };\n    }\n\n    /**\n     * Internal events.\n     * These events can't be emitted by the user.\n     */\n    const RESERVED_EVENTS = Object.freeze({\n        connect: 1,\n        connect_error: 1,\n        disconnect: 1,\n        disconnecting: 1,\n        // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n        newListener: 1,\n        removeListener: 1,\n    });\n    class Socket extends Emitter_1 {\n        /**\n         * `Socket` constructor.\n         *\n         * @public\n         */\n        constructor(io, nsp, opts) {\n            super();\n            this.connected = false;\n            this.disconnected = true;\n            this.receiveBuffer = [];\n            this.sendBuffer = [];\n            this.ids = 0;\n            this.acks = {};\n            this.flags = {};\n            this.io = io;\n            this.nsp = nsp;\n            if (opts && opts.auth) {\n                this.auth = opts.auth;\n            }\n            if (this.io._autoConnect)\n                this.open();\n        }\n        /**\n         * Subscribe to open, close and packet events\n         *\n         * @private\n         */\n        subEvents() {\n            if (this.subs)\n                return;\n            const io = this.io;\n            this.subs = [\n                on(io, \"open\", this.onopen.bind(this)),\n                on(io, \"packet\", this.onpacket.bind(this)),\n                on(io, \"error\", this.onerror.bind(this)),\n                on(io, \"close\", this.onclose.bind(this)),\n            ];\n        }\n        /**\n         * Whether the Socket will try to reconnect when its Manager connects or reconnects\n         */\n        get active() {\n            return !!this.subs;\n        }\n        /**\n         * \"Opens\" the socket.\n         *\n         * @public\n         */\n        connect() {\n            if (this.connected)\n                return this;\n            this.subEvents();\n            if (!this.io[\"_reconnecting\"])\n                this.io.open(); // ensure open\n            if (\"open\" === this.io._readyState)\n                this.onopen();\n            return this;\n        }\n        /**\n         * Alias for connect()\n         */\n        open() {\n            return this.connect();\n        }\n        /**\n         * Sends a `message` event.\n         *\n         * @return self\n         * @public\n         */\n        send(...args) {\n            args.unshift(\"message\");\n            this.emit.apply(this, args);\n            return this;\n        }\n        /**\n         * Override `emit`.\n         * If the event is in `events`, it's emitted normally.\n         *\n         * @return self\n         * @public\n         */\n        emit(ev, ...args) {\n            if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n                throw new Error('\"' + ev + '\" is a reserved event name');\n            }\n            args.unshift(ev);\n            const packet = {\n                type: PacketType.EVENT,\n                data: args,\n            };\n            packet.options = {};\n            packet.options.compress = this.flags.compress !== false;\n            // event ack callback\n            if (\"function\" === typeof args[args.length - 1]) {\n                this.acks[this.ids] = args.pop();\n                packet.id = this.ids++;\n            }\n            const isTransportWritable = this.io.engine &&\n                this.io.engine.transport &&\n                this.io.engine.transport.writable;\n            const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n            if (discardPacket) ;\n            else if (this.connected) {\n                this.packet(packet);\n            }\n            else {\n                this.sendBuffer.push(packet);\n            }\n            this.flags = {};\n            return this;\n        }\n        /**\n         * Sends a packet.\n         *\n         * @param packet\n         * @private\n         */\n        packet(packet) {\n            packet.nsp = this.nsp;\n            this.io._packet(packet);\n        }\n        /**\n         * Called upon engine `open`.\n         *\n         * @private\n         */\n        onopen() {\n            if (typeof this.auth == \"function\") {\n                this.auth((data) => {\n                    this.packet({ type: PacketType.CONNECT, data });\n                });\n            }\n            else {\n                this.packet({ type: PacketType.CONNECT, data: this.auth });\n            }\n        }\n        /**\n         * Called upon engine or manager `error`.\n         *\n         * @param err\n         * @private\n         */\n        onerror(err) {\n            if (!this.connected) {\n                this.emitReserved(\"connect_error\", err);\n            }\n        }\n        /**\n         * Called upon engine `close`.\n         *\n         * @param reason\n         * @private\n         */\n        onclose(reason) {\n            this.connected = false;\n            this.disconnected = true;\n            delete this.id;\n            this.emitReserved(\"disconnect\", reason);\n        }\n        /**\n         * Called with socket packet.\n         *\n         * @param packet\n         * @private\n         */\n        onpacket(packet) {\n            const sameNamespace = packet.nsp === this.nsp;\n            if (!sameNamespace)\n                return;\n            switch (packet.type) {\n                case PacketType.CONNECT:\n                    if (packet.data && packet.data.sid) {\n                        const id = packet.data.sid;\n                        this.onconnect(id);\n                    }\n                    else {\n                        this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                    }\n                    break;\n                case PacketType.EVENT:\n                    this.onevent(packet);\n                    break;\n                case PacketType.BINARY_EVENT:\n                    this.onevent(packet);\n                    break;\n                case PacketType.ACK:\n                    this.onack(packet);\n                    break;\n                case PacketType.BINARY_ACK:\n                    this.onack(packet);\n                    break;\n                case PacketType.DISCONNECT:\n                    this.ondisconnect();\n                    break;\n                case PacketType.CONNECT_ERROR:\n                    const err = new Error(packet.data.message);\n                    // @ts-ignore\n                    err.data = packet.data.data;\n                    this.emitReserved(\"connect_error\", err);\n                    break;\n            }\n        }\n        /**\n         * Called upon a server event.\n         *\n         * @param packet\n         * @private\n         */\n        onevent(packet) {\n            const args = packet.data || [];\n            if (null != packet.id) {\n                args.push(this.ack(packet.id));\n            }\n            if (this.connected) {\n                this.emitEvent(args);\n            }\n            else {\n                this.receiveBuffer.push(Object.freeze(args));\n            }\n        }\n        emitEvent(args) {\n            if (this._anyListeners && this._anyListeners.length) {\n                const listeners = this._anyListeners.slice();\n                for (const listener of listeners) {\n                    listener.apply(this, args);\n                }\n            }\n            super.emit.apply(this, args);\n        }\n        /**\n         * Produces an ack callback to emit with an event.\n         *\n         * @private\n         */\n        ack(id) {\n            const self = this;\n            let sent = false;\n            return function (...args) {\n                // prevent double callbacks\n                if (sent)\n                    return;\n                sent = true;\n                self.packet({\n                    type: PacketType.ACK,\n                    id: id,\n                    data: args,\n                });\n            };\n        }\n        /**\n         * Called upon a server acknowlegement.\n         *\n         * @param packet\n         * @private\n         */\n        onack(packet) {\n            const ack = this.acks[packet.id];\n            if (\"function\" === typeof ack) {\n                ack.apply(this, packet.data);\n                delete this.acks[packet.id];\n            }\n        }\n        /**\n         * Called upon server connect.\n         *\n         * @private\n         */\n        onconnect(id) {\n            this.id = id;\n            this.connected = true;\n            this.disconnected = false;\n            this.emitBuffered();\n            this.emitReserved(\"connect\");\n        }\n        /**\n         * Emit buffered events (received and emitted).\n         *\n         * @private\n         */\n        emitBuffered() {\n            this.receiveBuffer.forEach((args) => this.emitEvent(args));\n            this.receiveBuffer = [];\n            this.sendBuffer.forEach((packet) => this.packet(packet));\n            this.sendBuffer = [];\n        }\n        /**\n         * Called upon server disconnect.\n         *\n         * @private\n         */\n        ondisconnect() {\n            this.destroy();\n            this.onclose(\"io server disconnect\");\n        }\n        /**\n         * Called upon forced client/server side disconnections,\n         * this method ensures the manager stops tracking us and\n         * that reconnections don't get triggered for this.\n         *\n         * @private\n         */\n        destroy() {\n            if (this.subs) {\n                // clean subscriptions to avoid reconnections\n                this.subs.forEach((subDestroy) => subDestroy());\n                this.subs = undefined;\n            }\n            this.io[\"_destroy\"](this);\n        }\n        /**\n         * Disconnects the socket manually.\n         *\n         * @return self\n         * @public\n         */\n        disconnect() {\n            if (this.connected) {\n                this.packet({ type: PacketType.DISCONNECT });\n            }\n            // remove socket from pool\n            this.destroy();\n            if (this.connected) {\n                // fire events\n                this.onclose(\"io client disconnect\");\n            }\n            return this;\n        }\n        /**\n         * Alias for disconnect()\n         *\n         * @return self\n         * @public\n         */\n        close() {\n            return this.disconnect();\n        }\n        /**\n         * Sets the compress flag.\n         *\n         * @param compress - if `true`, compresses the sending data\n         * @return self\n         * @public\n         */\n        compress(compress) {\n            this.flags.compress = compress;\n            return this;\n        }\n        /**\n         * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n         * ready to send messages.\n         *\n         * @returns self\n         * @public\n         */\n        get volatile() {\n            this.flags.volatile = true;\n            return this;\n        }\n        /**\n         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n         * callback.\n         *\n         * @param listener\n         * @public\n         */\n        onAny(listener) {\n            this._anyListeners = this._anyListeners || [];\n            this._anyListeners.push(listener);\n            return this;\n        }\n        /**\n         * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n         * callback. The listener is added to the beginning of the listeners array.\n         *\n         * @param listener\n         * @public\n         */\n        prependAny(listener) {\n            this._anyListeners = this._anyListeners || [];\n            this._anyListeners.unshift(listener);\n            return this;\n        }\n        /**\n         * Removes the listener that will be fired when any event is emitted.\n         *\n         * @param listener\n         * @public\n         */\n        offAny(listener) {\n            if (!this._anyListeners) {\n                return this;\n            }\n            if (listener) {\n                const listeners = this._anyListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                    if (listener === listeners[i]) {\n                        listeners.splice(i, 1);\n                        return this;\n                    }\n                }\n            }\n            else {\n                this._anyListeners = [];\n            }\n            return this;\n        }\n        /**\n         * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n         * e.g. to remove listeners.\n         *\n         * @public\n         */\n        listenersAny() {\n            return this._anyListeners || [];\n        }\n    }\n\n    /**\n     * Expose `Backoff`.\n     */\n\n    var backo2 = Backoff;\n\n    /**\n     * Initialize backoff timer with `opts`.\n     *\n     * - `min` initial timeout in milliseconds [100]\n     * - `max` max timeout [10000]\n     * - `jitter` [0]\n     * - `factor` [2]\n     *\n     * @param {Object} opts\n     * @api public\n     */\n\n    function Backoff(opts) {\n      opts = opts || {};\n      this.ms = opts.min || 100;\n      this.max = opts.max || 10000;\n      this.factor = opts.factor || 2;\n      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n      this.attempts = 0;\n    }\n\n    /**\n     * Return the backoff duration.\n     *\n     * @return {Number}\n     * @api public\n     */\n\n    Backoff.prototype.duration = function(){\n      var ms = this.ms * Math.pow(this.factor, this.attempts++);\n      if (this.jitter) {\n        var rand =  Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n      }\n      return Math.min(ms, this.max) | 0;\n    };\n\n    /**\n     * Reset the number of attempts.\n     *\n     * @api public\n     */\n\n    Backoff.prototype.reset = function(){\n      this.attempts = 0;\n    };\n\n    /**\n     * Set the minimum duration\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setMin = function(min){\n      this.ms = min;\n    };\n\n    /**\n     * Set the maximum duration\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setMax = function(max){\n      this.max = max;\n    };\n\n    /**\n     * Set the jitter\n     *\n     * @api public\n     */\n\n    Backoff.prototype.setJitter = function(jitter){\n      this.jitter = jitter;\n    };\n\n    class Manager extends Emitter_1 {\n        constructor(uri, opts) {\n            var _a;\n            super();\n            this.nsps = {};\n            this.subs = [];\n            if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = undefined;\n            }\n            opts = opts || {};\n            opts.path = opts.path || \"/socket.io\";\n            this.opts = opts;\n            installTimerFunctions(this, opts);\n            this.reconnection(opts.reconnection !== false);\n            this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n            this.reconnectionDelay(opts.reconnectionDelay || 1000);\n            this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n            this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n            this.backoff = new backo2({\n                min: this.reconnectionDelay(),\n                max: this.reconnectionDelayMax(),\n                jitter: this.randomizationFactor(),\n            });\n            this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n            this._readyState = \"closed\";\n            this.uri = uri;\n            const _parser = opts.parser || parser;\n            this.encoder = new _parser.Encoder();\n            this.decoder = new _parser.Decoder();\n            this._autoConnect = opts.autoConnect !== false;\n            if (this._autoConnect)\n                this.open();\n        }\n        reconnection(v) {\n            if (!arguments.length)\n                return this._reconnection;\n            this._reconnection = !!v;\n            return this;\n        }\n        reconnectionAttempts(v) {\n            if (v === undefined)\n                return this._reconnectionAttempts;\n            this._reconnectionAttempts = v;\n            return this;\n        }\n        reconnectionDelay(v) {\n            var _a;\n            if (v === undefined)\n                return this._reconnectionDelay;\n            this._reconnectionDelay = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n            return this;\n        }\n        randomizationFactor(v) {\n            var _a;\n            if (v === undefined)\n                return this._randomizationFactor;\n            this._randomizationFactor = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n            return this;\n        }\n        reconnectionDelayMax(v) {\n            var _a;\n            if (v === undefined)\n                return this._reconnectionDelayMax;\n            this._reconnectionDelayMax = v;\n            (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n            return this;\n        }\n        timeout(v) {\n            if (!arguments.length)\n                return this._timeout;\n            this._timeout = v;\n            return this;\n        }\n        /**\n         * Starts trying to reconnect if reconnection is enabled and we have not\n         * started reconnecting yet\n         *\n         * @private\n         */\n        maybeReconnectOnOpen() {\n            // Only try to reconnect if it's the first time we're connecting\n            if (!this._reconnecting &&\n                this._reconnection &&\n                this.backoff.attempts === 0) {\n                // keeps reconnection from firing twice for the same reconnection loop\n                this.reconnect();\n            }\n        }\n        /**\n         * Sets the current transport `socket`.\n         *\n         * @param {Function} fn - optional, callback\n         * @return self\n         * @public\n         */\n        open(fn) {\n            if (~this._readyState.indexOf(\"open\"))\n                return this;\n            this.engine = new Socket$1(this.uri, this.opts);\n            const socket = this.engine;\n            const self = this;\n            this._readyState = \"opening\";\n            this.skipReconnect = false;\n            // emit `open`\n            const openSubDestroy = on(socket, \"open\", function () {\n                self.onopen();\n                fn && fn();\n            });\n            // emit `error`\n            const errorSub = on(socket, \"error\", (err) => {\n                self.cleanup();\n                self._readyState = \"closed\";\n                this.emitReserved(\"error\", err);\n                if (fn) {\n                    fn(err);\n                }\n                else {\n                    // Only do this if there is no fn to handle the error\n                    self.maybeReconnectOnOpen();\n                }\n            });\n            if (false !== this._timeout) {\n                const timeout = this._timeout;\n                if (timeout === 0) {\n                    openSubDestroy(); // prevents a race condition with the 'open' event\n                }\n                // set timer\n                const timer = this.setTimeoutFn(() => {\n                    openSubDestroy();\n                    socket.close();\n                    // @ts-ignore\n                    socket.emit(\"error\", new Error(\"timeout\"));\n                }, timeout);\n                if (this.opts.autoUnref) {\n                    timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                    clearTimeout(timer);\n                });\n            }\n            this.subs.push(openSubDestroy);\n            this.subs.push(errorSub);\n            return this;\n        }\n        /**\n         * Alias for open()\n         *\n         * @return self\n         * @public\n         */\n        connect(fn) {\n            return this.open(fn);\n        }\n        /**\n         * Called upon transport open.\n         *\n         * @private\n         */\n        onopen() {\n            // clear old subs\n            this.cleanup();\n            // mark as open\n            this._readyState = \"open\";\n            this.emitReserved(\"open\");\n            // add new subs\n            const socket = this.engine;\n            this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n        }\n        /**\n         * Called upon a ping.\n         *\n         * @private\n         */\n        onping() {\n            this.emitReserved(\"ping\");\n        }\n        /**\n         * Called with data.\n         *\n         * @private\n         */\n        ondata(data) {\n            this.decoder.add(data);\n        }\n        /**\n         * Called when parser fully decodes a packet.\n         *\n         * @private\n         */\n        ondecoded(packet) {\n            this.emitReserved(\"packet\", packet);\n        }\n        /**\n         * Called upon socket error.\n         *\n         * @private\n         */\n        onerror(err) {\n            this.emitReserved(\"error\", err);\n        }\n        /**\n         * Creates a new socket for the given `nsp`.\n         *\n         * @return {Socket}\n         * @public\n         */\n        socket(nsp, opts) {\n            let socket = this.nsps[nsp];\n            if (!socket) {\n                socket = new Socket(this, nsp, opts);\n                this.nsps[nsp] = socket;\n            }\n            return socket;\n        }\n        /**\n         * Called upon a socket close.\n         *\n         * @param socket\n         * @private\n         */\n        _destroy(socket) {\n            const nsps = Object.keys(this.nsps);\n            for (const nsp of nsps) {\n                const socket = this.nsps[nsp];\n                if (socket.active) {\n                    return;\n                }\n            }\n            this._close();\n        }\n        /**\n         * Writes a packet.\n         *\n         * @param packet\n         * @private\n         */\n        _packet(packet) {\n            const encodedPackets = this.encoder.encode(packet);\n            for (let i = 0; i < encodedPackets.length; i++) {\n                this.engine.write(encodedPackets[i], packet.options);\n            }\n        }\n        /**\n         * Clean up transport subscriptions and packet buffer.\n         *\n         * @private\n         */\n        cleanup() {\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs.length = 0;\n            this.decoder.destroy();\n        }\n        /**\n         * Close the current socket.\n         *\n         * @private\n         */\n        _close() {\n            this.skipReconnect = true;\n            this._reconnecting = false;\n            if (\"opening\" === this._readyState) {\n                // `onclose` will not fire because\n                // an open event never happened\n                this.cleanup();\n            }\n            this.backoff.reset();\n            this._readyState = \"closed\";\n            if (this.engine)\n                this.engine.close();\n        }\n        /**\n         * Alias for close()\n         *\n         * @private\n         */\n        disconnect() {\n            return this._close();\n        }\n        /**\n         * Called upon engine close.\n         *\n         * @private\n         */\n        onclose(reason) {\n            this.cleanup();\n            this.backoff.reset();\n            this._readyState = \"closed\";\n            this.emitReserved(\"close\", reason);\n            if (this._reconnection && !this.skipReconnect) {\n                this.reconnect();\n            }\n        }\n        /**\n         * Attempt a reconnection.\n         *\n         * @private\n         */\n        reconnect() {\n            if (this._reconnecting || this.skipReconnect)\n                return this;\n            const self = this;\n            if (this.backoff.attempts >= this._reconnectionAttempts) {\n                this.backoff.reset();\n                this.emitReserved(\"reconnect_failed\");\n                this._reconnecting = false;\n            }\n            else {\n                const delay = this.backoff.duration();\n                this._reconnecting = true;\n                const timer = this.setTimeoutFn(() => {\n                    if (self.skipReconnect)\n                        return;\n                    this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                    // check again for the case socket closed in above events\n                    if (self.skipReconnect)\n                        return;\n                    self.open((err) => {\n                        if (err) {\n                            self._reconnecting = false;\n                            self.reconnect();\n                            this.emitReserved(\"reconnect_error\", err);\n                        }\n                        else {\n                            self.onreconnect();\n                        }\n                    });\n                }, delay);\n                if (this.opts.autoUnref) {\n                    timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                    clearTimeout(timer);\n                });\n            }\n        }\n        /**\n         * Called upon successful reconnect.\n         *\n         * @private\n         */\n        onreconnect() {\n            const attempt = this.backoff.attempts;\n            this._reconnecting = false;\n            this.backoff.reset();\n            this.emitReserved(\"reconnect\", attempt);\n        }\n    }\n\n    /**\n     * Managers cache.\n     */\n    const cache = {};\n    function lookup(uri, opts) {\n        if (typeof uri === \"object\") {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        const parsed = url(uri, opts.path || \"/socket.io\");\n        const source = parsed.source;\n        const id = parsed.id;\n        const path = parsed.path;\n        const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n        const newConnection = opts.forceNew ||\n            opts[\"force new connection\"] ||\n            false === opts.multiplex ||\n            sameNamespace;\n        let io;\n        if (newConnection) {\n            io = new Manager(source, opts);\n        }\n        else {\n            if (!cache[id]) {\n                cache[id] = new Manager(source, opts);\n            }\n            io = cache[id];\n        }\n        if (parsed.query && !opts.query) {\n            opts.query = parsed.queryKey;\n        }\n        return io.socket(parsed.path, opts);\n    }\n    // so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n    // namespace (e.g. `io.connect(...)`), for backward compatibility\n    Object.assign(lookup, {\n        Manager,\n        Socket,\n        io: lookup,\n        connect: lookup,\n    });\n\n    /* src\\components\\chat.svelte generated by Svelte v3.44.1 */\n\n    const { console: console_1 } = globals;\n    const file$1 = \"src\\\\components\\\\chat.svelte\";\n\n    function get_each_context(ctx, list, i) {\n    \tconst child_ctx = ctx.slice();\n    \tchild_ctx[8] = list[i];\n    \tchild_ctx[10] = i;\n    \treturn child_ctx;\n    }\n\n    // (237:4) {#each chatHistory as chatMessage, i}\n    function create_each_block(ctx) {\n    \tlet div;\n    \tlet h4;\n    \tlet t0_value = /*chatMessage*/ ctx[8].user + \"\";\n    \tlet t0;\n    \tlet t1;\n    \tlet p;\n    \tlet t2_value = /*chatMessage*/ ctx[8].msg + \"\";\n    \tlet t2;\n    \tlet t3;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tdiv = element(\"div\");\n    \t\t\th4 = element(\"h4\");\n    \t\t\tt0 = text(t0_value);\n    \t\t\tt1 = space();\n    \t\t\tp = element(\"p\");\n    \t\t\tt2 = text(t2_value);\n    \t\t\tt3 = space();\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tdiv = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div_nodes = children(div);\n    \t\t\th4 = claim_element(div_nodes, \"H4\", { class: true });\n    \t\t\tvar h4_nodes = children(h4);\n    \t\t\tt0 = claim_text(h4_nodes, t0_value);\n    \t\t\th4_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(div_nodes);\n    \t\t\tp = claim_element(div_nodes, \"P\", { class: true });\n    \t\t\tvar p_nodes = children(p);\n    \t\t\tt2 = claim_text(p_nodes, t2_value);\n    \t\t\tp_nodes.forEach(detach_dev);\n    \t\t\tt3 = claim_space(div_nodes);\n    \t\t\tdiv_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h4, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(h4, file$1, 238, 12, 5081);\n    \t\t\tattr_dev(p, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(p, file$1, 239, 12, 5122);\n    \t\t\tattr_dev(div, \"class\", \"client-message svelte-127bm7n\");\n    \t\t\tadd_location(div, file$1, 237, 8, 5039);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, div, anchor);\n    \t\t\tappend_hydration_dev(div, h4);\n    \t\t\tappend_hydration_dev(h4, t0);\n    \t\t\tappend_hydration_dev(div, t1);\n    \t\t\tappend_hydration_dev(div, p);\n    \t\t\tappend_hydration_dev(p, t2);\n    \t\t\tappend_hydration_dev(div, t3);\n    \t\t},\n    \t\tp: function update(ctx, dirty) {\n    \t\t\tif (dirty & /*chatHistory*/ 1 && t0_value !== (t0_value = /*chatMessage*/ ctx[8].user + \"\")) set_data_dev(t0, t0_value);\n    \t\t\tif (dirty & /*chatHistory*/ 1 && t2_value !== (t2_value = /*chatMessage*/ ctx[8].msg + \"\")) set_data_dev(t2, t2_value);\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(div);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_each_block.name,\n    \t\ttype: \"each\",\n    \t\tsource: \"(237:4) {#each chatHistory as chatMessage, i}\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function create_fragment$1(ctx) {\n    \tlet h1;\n    \tlet t0;\n    \tlet t1;\n    \tlet div0;\n    \tlet t2;\n    \tlet div1;\n    \tlet fieldset;\n    \tlet t3;\n    \tlet svg;\n    \tlet path;\n    \tlet mounted;\n    \tlet dispose;\n    \tlet each_value = /*chatHistory*/ ctx[0];\n    \tvalidate_each_argument(each_value);\n    \tlet each_blocks = [];\n\n    \tfor (let i = 0; i < each_value.length; i += 1) {\n    \t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    \t}\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\th1 = element(\"h1\");\n    \t\t\tt0 = text(\"CHAT\");\n    \t\t\tt1 = space();\n    \t\t\tdiv0 = element(\"div\");\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].c();\n    \t\t\t}\n\n    \t\t\tt2 = space();\n    \t\t\tdiv1 = element(\"div\");\n    \t\t\tfieldset = element(\"fieldset\");\n    \t\t\tt3 = space();\n    \t\t\tsvg = svg_element(\"svg\");\n    \t\t\tpath = svg_element(\"path\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\th1 = claim_element(nodes, \"H1\", { class: true });\n    \t\t\tvar h1_nodes = children(h1);\n    \t\t\tt0 = claim_text(h1_nodes, \"CHAT\");\n    \t\t\th1_nodes.forEach(detach_dev);\n    \t\t\tt1 = claim_space(nodes);\n    \t\t\tdiv0 = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div0_nodes = children(div0);\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].l(div0_nodes);\n    \t\t\t}\n\n    \t\t\tdiv0_nodes.forEach(detach_dev);\n    \t\t\tt2 = claim_space(nodes);\n    \t\t\tdiv1 = claim_element(nodes, \"DIV\", { class: true });\n    \t\t\tvar div1_nodes = children(div1);\n    \t\t\tfieldset = claim_element(div1_nodes, \"FIELDSET\", { contenteditable: true, class: true });\n    \t\t\tchildren(fieldset).forEach(detach_dev);\n    \t\t\tt3 = claim_space(div1_nodes);\n\n    \t\t\tsvg = claim_svg_element(div1_nodes, \"svg\", {\n    \t\t\t\txmlns: true,\n    \t\t\t\twidth: true,\n    \t\t\t\theight: true,\n    \t\t\t\tviewBox: true,\n    \t\t\t\tclass: true\n    \t\t\t});\n\n    \t\t\tvar svg_nodes = children(svg);\n\n    \t\t\tpath = claim_svg_element(svg_nodes, \"path\", {\n    \t\t\t\tid: true,\n    \t\t\t\t\"data-name\": true,\n    \t\t\t\td: true,\n    \t\t\t\ttransform: true,\n    \t\t\t\tfill: true\n    \t\t\t});\n\n    \t\t\tchildren(path).forEach(detach_dev);\n    \t\t\tsvg_nodes.forEach(detach_dev);\n    \t\t\tdiv1_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(h1, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(h1, file$1, 233, 0, 4946);\n    \t\t\tattr_dev(div0, \"class\", \"chat-view svelte-127bm7n\");\n    \t\t\tadd_location(div0, file$1, 235, 0, 4963);\n    \t\t\tattr_dev(fieldset, \"contenteditable\", \"true\");\n    \t\t\tattr_dev(fieldset, \"class\", \"svelte-127bm7n\");\n    \t\t\tif (/*newMessage*/ ctx[1] === void 0) add_render_callback(() => /*fieldset_input_handler*/ ctx[3].call(fieldset));\n    \t\t\tadd_location(fieldset, file$1, 245, 4, 5218);\n    \t\t\tattr_dev(path, \"id\", \"Path_3\");\n    \t\t\tattr_dev(path, \"data-name\", \"Path 3\");\n    \t\t\tattr_dev(path, \"d\", \"M45.912.281,1.215,26.067a2.316,2.316,0,0,0,.212,4.166l10.251,4.3L39.383,10.117a.578.578,0,0,1,.829.8l-23.231,28.3v7.763a2.314,2.314,0,0,0,4.1,1.524L27.2,41.053l12.016,5.034A2.321,2.321,0,0,0,42.4,44.332L49.345,2.672A2.315,2.315,0,0,0,45.912.281Z\");\n    \t\t\tattr_dev(path, \"transform\", \"translate(-0.01 0.031)\");\n    \t\t\tattr_dev(path, \"fill\", \"#1e88e5\");\n    \t\t\tadd_location(path, file$1, 247, 8, 5429);\n    \t\t\tattr_dev(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n    \t\t\tattr_dev(svg, \"width\", \"49.369\");\n    \t\t\tattr_dev(svg, \"height\", \"49.384\");\n    \t\t\tattr_dev(svg, \"viewBox\", \"0 0 49.369 49.384\");\n    \t\t\tattr_dev(svg, \"class\", \"svelte-127bm7n\");\n    \t\t\tadd_location(svg, file$1, 246, 4, 5289);\n    \t\t\tattr_dev(div1, \"class\", \"message-box svelte-127bm7n\");\n    \t\t\tadd_location(div1, file$1, 244, 0, 5187);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, h1, anchor);\n    \t\t\tappend_hydration_dev(h1, t0);\n    \t\t\tinsert_hydration_dev(target, t1, anchor);\n    \t\t\tinsert_hydration_dev(target, div0, anchor);\n\n    \t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n    \t\t\t\teach_blocks[i].m(div0, null);\n    \t\t\t}\n\n    \t\t\tinsert_hydration_dev(target, t2, anchor);\n    \t\t\tinsert_hydration_dev(target, div1, anchor);\n    \t\t\tappend_hydration_dev(div1, fieldset);\n\n    \t\t\tif (/*newMessage*/ ctx[1] !== void 0) {\n    \t\t\t\tfieldset.textContent = /*newMessage*/ ctx[1];\n    \t\t\t}\n\n    \t\t\tappend_hydration_dev(div1, t3);\n    \t\t\tappend_hydration_dev(div1, svg);\n    \t\t\tappend_hydration_dev(svg, path);\n\n    \t\t\tif (!mounted) {\n    \t\t\t\tdispose = [\n    \t\t\t\t\tlisten_dev(fieldset, \"input\", /*fieldset_input_handler*/ ctx[3]),\n    \t\t\t\t\tlisten_dev(svg, \"click\", /*click_handler*/ ctx[4], false, false, false)\n    \t\t\t\t];\n\n    \t\t\t\tmounted = true;\n    \t\t\t}\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tif (dirty & /*chatHistory*/ 1) {\n    \t\t\t\teach_value = /*chatHistory*/ ctx[0];\n    \t\t\t\tvalidate_each_argument(each_value);\n    \t\t\t\tlet i;\n\n    \t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n    \t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n    \t\t\t\t\tif (each_blocks[i]) {\n    \t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n    \t\t\t\t\t\teach_blocks[i].c();\n    \t\t\t\t\t\teach_blocks[i].m(div0, null);\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t\tfor (; i < each_blocks.length; i += 1) {\n    \t\t\t\t\teach_blocks[i].d(1);\n    \t\t\t\t}\n\n    \t\t\t\teach_blocks.length = each_value.length;\n    \t\t\t}\n\n    \t\t\tif (dirty & /*newMessage*/ 2 && /*newMessage*/ ctx[1] !== fieldset.textContent) {\n    \t\t\t\tfieldset.textContent = /*newMessage*/ ctx[1];\n    \t\t\t}\n    \t\t},\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(h1);\n    \t\t\tif (detaching) detach_dev(t1);\n    \t\t\tif (detaching) detach_dev(div0);\n    \t\t\tdestroy_each(each_blocks, detaching);\n    \t\t\tif (detaching) detach_dev(t2);\n    \t\t\tif (detaching) detach_dev(div1);\n    \t\t\tmounted = false;\n    \t\t\trun_all(dispose);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment$1.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance$1($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Chat', slots, []);\n    \tconst socket = lookup(\"localhost:3002\");\n    \tlet { chatHistory = [] } = $$props;\n\n    \t// Client socket callback that occurs on connection to server. \n    \tsocket.on(\"connect\", () => {\n    \t\t// either with send()  socket.send(\"Hello!\");\n    \t\t// or with emit() and custom event names \n    \t\t//let clientConnected = `CLIENT connected from ...`;\n    \t\t//socket.emit(\"clientConnect\", clientConnected);\n    \t\tconsole.log(\"Connected to server\");\n\n    \t\t// Client socket listening to specific key emit from server socket\n    \t\tsocket.on(\"serverMessage\", (user, msg) => {\n    \t\t\tAddMessage(user, msg);\n\n    \t\t\t// Force update so reactivity works\n    \t\t\t$$invalidate(0, chatHistory);\n    \t\t});\n    \t});\n\n    \tconst AddMessage = (user, msg) => {\n    \t\tlet chatObj = { user, msg };\n    \t\tchatHistory.push(chatObj);\n\n    \t\t// Clientside logging\n    \t\tconsole.log(\"Client Message: \" + msg);\n    \t};\n\n    \tlet username = \"Guest\";\n    \tlet newMessage = \"\";\n\n    \t/* Example request for a server emit\r\n    const TestData = async() => {\r\n        let response = await fetch(\"/test\");\r\n        if(!response.ok) return console.error(\"ERROR FETCH\");\r\n    }\r\n    */\n    \t//socket.emit(\"clientMessage\", newMessage);\n    \tconst SendMessage = async () => {\n    \t\tlet msgObj = { username, newMessage };\n\n    \t\tlet response = await fetch(\"/chat/message\", {\n    \t\t\tmethod: \"POST\",\n    \t\t\theaders: {\n    \t\t\t\t\"Content-Type\": \"application/json;charset=utf-8\"\n    \t\t\t},\n    \t\t\tbody: JSON.stringify(msgObj)\n    \t\t});\n\n    \t\tif (!response.ok) return console.error(\"Could not send message!\");\n    \t\tresponse.text();\n    \t}; //console.log(result);\n\n    \tconst writable_props = ['chatHistory'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Chat> was created with unknown prop '${key}'`);\n    \t});\n\n    \tfunction fieldset_input_handler() {\n    \t\tnewMessage = this.textContent;\n    \t\t$$invalidate(1, newMessage);\n    \t}\n\n    \tconst click_handler = () => SendMessage();\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \t$$self.$capture_state = () => ({\n    \t\tio: lookup,\n    \t\tsocket,\n    \t\tchatHistory,\n    \t\tAddMessage,\n    \t\tusername,\n    \t\tnewMessage,\n    \t\tSendMessage\n    \t});\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t\tif ('username' in $$props) username = $$props.username;\n    \t\tif ('newMessage' in $$props) $$invalidate(1, newMessage = $$props.newMessage);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \t$$self.$$.update = () => {\n    \t\tif ($$self.$$.dirty & /*chatHistory*/ 1) ;\n    \t};\n\n    \treturn [chatHistory, newMessage, SendMessage, fieldset_input_handler, click_handler];\n    }\n\n    class Chat extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance$1, create_fragment$1, safe_not_equal, { chatHistory: 0 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Chat\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment$1.name\n    \t\t});\n    \t}\n\n    \tget chatHistory() {\n    \t\tthrow new Error(\"<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset chatHistory(value) {\n    \t\tthrow new Error(\"<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }\n\n    /* src\\routes\\index.svelte generated by Svelte v3.44.1 */\n    const file = \"src\\\\routes\\\\index.svelte\";\n\n    function create_fragment(ctx) {\n    \tlet main;\n    \tlet chat;\n    \tlet t0;\n    \tlet footer;\n    \tlet t1;\n    \tlet a;\n    \tlet t2;\n    \tlet current;\n\n    \tchat = new Chat({\n    \t\t\tprops: { chatHistory: /*chatHistory*/ ctx[0] },\n    \t\t\t$$inline: true\n    \t\t});\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\tmain = element(\"main\");\n    \t\t\tcreate_component(chat.$$.fragment);\n    \t\t\tt0 = space();\n    \t\t\tfooter = element(\"footer\");\n    \t\t\tt1 = text(\"Copyright 2021 - \");\n    \t\t\ta = element(\"a\");\n    \t\t\tt2 = text(\"ignurof.xyz\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\tmain = claim_element(nodes, \"MAIN\", { class: true });\n    \t\t\tvar main_nodes = children(main);\n    \t\t\tclaim_component(chat.$$.fragment, main_nodes);\n    \t\t\tmain_nodes.forEach(detach_dev);\n    \t\t\tt0 = claim_space(nodes);\n    \t\t\tfooter = claim_element(nodes, \"FOOTER\", { class: true });\n    \t\t\tvar footer_nodes = children(footer);\n    \t\t\tt1 = claim_text(footer_nodes, \"Copyright 2021 - \");\n    \t\t\ta = claim_element(footer_nodes, \"A\", { href: true, target: true, class: true });\n    \t\t\tvar a_nodes = children(a);\n    \t\t\tt2 = claim_text(a_nodes, \"ignurof.xyz\");\n    \t\t\ta_nodes.forEach(detach_dev);\n    \t\t\tfooter_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(main, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(main, file, 47, 0, 796);\n    \t\t\tattr_dev(a, \"href\", \"https://ignurof.xyz\");\n    \t\t\tattr_dev(a, \"target\", \"_blank\");\n    \t\t\tattr_dev(a, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(a, file, 51, 21, 871);\n    \t\t\tattr_dev(footer, \"class\", \"svelte-1w3n4eh\");\n    \t\t\tadd_location(footer, file, 50, 0, 840);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, main, anchor);\n    \t\t\tmount_component(chat, main, null);\n    \t\t\tinsert_hydration_dev(target, t0, anchor);\n    \t\t\tinsert_hydration_dev(target, footer, anchor);\n    \t\t\tappend_hydration_dev(footer, t1);\n    \t\t\tappend_hydration_dev(footer, a);\n    \t\t\tappend_hydration_dev(a, t2);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\tp: function update(ctx, [dirty]) {\n    \t\t\tconst chat_changes = {};\n    \t\t\tif (dirty & /*chatHistory*/ 1) chat_changes.chatHistory = /*chatHistory*/ ctx[0];\n    \t\t\tchat.$set(chat_changes);\n    \t\t},\n    \t\ti: function intro(local) {\n    \t\t\tif (current) return;\n    \t\t\ttransition_in(chat.$$.fragment, local);\n    \t\t\tcurrent = true;\n    \t\t},\n    \t\to: function outro(local) {\n    \t\t\ttransition_out(chat.$$.fragment, local);\n    \t\t\tcurrent = false;\n    \t\t},\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(main);\n    \t\t\tdestroy_component(chat);\n    \t\t\tif (detaching) detach_dev(t0);\n    \t\t\tif (detaching) detach_dev(footer);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props, $$invalidate) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Routes', slots, []);\n    \tlet { chatHistory = [] } = $$props;\n    \tconst writable_props = ['chatHistory'];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);\n    \t});\n\n    \t$$self.$$set = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \t$$self.$capture_state = () => ({ Chat, chatHistory });\n\n    \t$$self.$inject_state = $$props => {\n    \t\tif ('chatHistory' in $$props) $$invalidate(0, chatHistory = $$props.chatHistory);\n    \t};\n\n    \tif ($$props && \"$$inject\" in $$props) {\n    \t\t$$self.$inject_state($$props.$$inject);\n    \t}\n\n    \treturn [chatHistory];\n    }\n\n    class Routes extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, { chatHistory: 0 });\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Routes\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n    \t}\n\n    \tget chatHistory() {\n    \t\tthrow new Error(\"<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n\n    \tset chatHistory(value) {\n    \t\tthrow new Error(\"<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'\");\n    \t}\n    }\n\n    return Routes;\n\n})();\n",
            "dynamicImports": [],
            "fileName": "index.js",
            "implicitlyLoadedBefore": [],
            "importedBindings": {},
            "imports": [],
            "map": null,
            "referencedFiles": []
        },
        "watchFiles": [
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\routes\\index.css",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.svelte",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\src\\components\\chat.css",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\svelte\\internal\\index.mjs",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\url.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\manager.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\socket.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\build\\esm\\on.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\binary.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\build\\esm\\is-binary.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\@socket.io\\component-emitter\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\@socket.io\\component-emitter\\index.js?commonjs-exports",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseuri\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\backo2\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\socket.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transport.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\util.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\polling-xhr.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\websocket.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\globalThis.browser.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseqs\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\polling.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\parseqs\\index.js?commonjs-exports",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\xmlhttprequest.browser.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-client\\build\\esm\\transports\\websocket-constructor.browser.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\decodePacket.browser.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\encodePacket.browser.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\yeast\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\engine.io-parser\\build\\esm\\commons.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\base64-arraybuffer\\dist\\base64-arraybuffer.es5.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\has-cors\\index.js",
            "C:\\Users\\ignur\\Desktop\\Portfolio\\socketio-chat\\node_modules\\has-cors\\index.js?commonjs-module"
        ]
    },
    "hashes": {
        "js": "5f3244cd0b0e10eaaaa0b1e4feafa42c",
        "css": "7b5c6fff8b6064e139605904325b746b"
    }
}